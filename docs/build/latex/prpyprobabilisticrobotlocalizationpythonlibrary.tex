%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{prpy: Probabilistic Robot Localization Python Library}
\date{Nov 13, 2023}
\release{0.1}
\author{Pere Ridao}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
\sphinxstylestrong{Probabilistic Robot Localization} is Python Library containing the main algorithms explained in the \sphinxstylestrong{Probabilisitic Robot Localization} Book used in the \sphinxstylestrong{Probabilisitic Robotics} and the \sphinxstylestrong{Hands\sphinxhyphen{}on Localization} Courses of the \sphinxstylestrong{Intelligent Field Robotic Systems (IFRoS)} European Erasmus Mundus Master.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
This documentation is still under construction.
\end{sphinxadmonition}


\chapter{API:}
\label{\detokenize{index:api}}
\sphinxstepscope


\section{Pose Representation}
\label{\detokenize{Pose:pose-representation}}\label{\detokenize{Pose::doc}}

\subsection{Pose}
\label{\detokenize{Pose:pose}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{Pose}.png}
\end{figure}
\index{Pose (class in Pose)@\spxentry{Pose}\spxextra{class in Pose}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Pose:Pose.Pose}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{Pose.}}\sphinxbfcode{\sphinxupquote{Pose}}}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{ndarray}}

\sphinxAtStartPar
Definition of a robot pose interface from where all the particular poses of different DOF inherit.
This class defines a robot pose AxB as the pose of the B\sphinxhyphen{}Frame expressed in the A\sphinxhyphen{}Frame coordinates.
\index{oplus() (Pose.Pose method)@\spxentry{oplus()}\spxextra{Pose.Pose method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Pose:Pose.Pose.oplus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{oplus}}}{\sphinxparam{\DUrole{n}{BxC}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Given a Pose object \sphinxstyleemphasis{AxB} (the self object) and a Pose object \sphinxstyleemphasis{BxC}, it returns the compounded Pose object \sphinxstyleemphasis{AxC}.

\sphinxAtStartPar
The operation is defined as:
\begin{equation}\label{equation:Pose:eq-oplus}
\begin{split}\mathbf{{^A}x_C} = \mathbf{{^A}x_B} \oplus \mathbf{{^B}x_C}\end{split}
\end{equation}
\sphinxAtStartPar
\sphinxstylestrong{This is a pure virtual method that must be implemented by a child class.}
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{BxC}} \textendash{} C\sphinxhyphen{}Frame pose expressed in B\sphinxhyphen{}Frame coordinates

\sphinxlineitem{Returns}
\sphinxAtStartPar
C\sphinxhyphen{}Frame pose expressed in A\sphinxhyphen{}Frame coordinates

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_1oplus() (Pose.Pose method)@\spxentry{J\_1oplus()}\spxextra{Pose.Pose method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Pose:Pose.Pose.J_1oplus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{J\_1oplus}}}{\sphinxparam{\DUrole{n}{BxC}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the pose compounding operation (eq. \eqref{equation:Pose:eq-oplus}) with respect to the first pose:
\begin{equation}\label{equation:Pose:eq-J1oplus}
\begin{split}J_{1\oplus}=\frac{\partial  ^Ax_B \oplus ^Bx_C}{\partial ^Ax_B}\end{split}
\end{equation}
\sphinxAtStartPar
The method returns a numerical matrix containing the evaluation of the Jacobian for the pose \sphinxstyleemphasis{AxB} (the self object) and the \(2^{nd}\) pose \sphinxstyleemphasis{BxC}.

\sphinxAtStartPar
\sphinxstylestrong{This is a pure virtual method that must be implemented by a child class.}
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{BxC}} \textendash{} 2nd pose

\sphinxlineitem{Returns}
\sphinxAtStartPar
Evaluation of the \(J_{1\oplus}\) Jacobian of the pose compounding operation with respect to the first pose (eq. \eqref{equation:Pose:eq-J1oplus})

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_2oplus() (Pose.Pose method)@\spxentry{J\_2oplus()}\spxextra{Pose.Pose method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Pose:Pose.Pose.J_2oplus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{J\_2oplus}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the pose compounding operation (\eqref{equation:Pose:eq-oplus}) with respect to the second pose:
\begin{equation}\label{equation:Pose:eq-J2oplus}
\begin{split}J_{2\oplus}=\frac{\partial  ^Ax_B \oplus ^Bx_C}{\partial ^Bx_C}\end{split}
\end{equation}
\sphinxAtStartPar
The method returns a numerical matrix containing the evaluation of the Jacobian for the \(1^{st}\) pose \sphinxstyleemphasis{AxB} (the self object).

\sphinxAtStartPar
\sphinxstylestrong{This is a pure virtual method that must be implemented by a child class.}
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Evaluation of the \(J_{2\oplus}\) Jacobian of the pose compounding operation with respect to the second pose (eq. \eqref{equation:Pose:eq-J2oplus})

\end{description}\end{quote}

\end{fulllineitems}

\index{ominus() (Pose.Pose method)@\spxentry{ominus()}\spxextra{Pose.Pose method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Pose:Pose.Pose.ominus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ominus}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Inverse pose compounding of the \sphinxstyleemphasis{AxB} pose (the self object):
\begin{equation}\label{equation:Pose:eq-ominus}
\begin{split}^Bx_A = \ominus ^Ax_B\end{split}
\end{equation}
\sphinxAtStartPar
\sphinxstylestrong{This is a pure virtual method that must be implemented by a child class.}
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
A\sphinxhyphen{}Frame pose expressed in B\sphinxhyphen{}Frame coordinates (eq. \eqref{equation:Pose:eq-ominus})

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_ominus() (Pose.Pose method)@\spxentry{J\_ominus()}\spxextra{Pose.Pose method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Pose:Pose.Pose.J_ominus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{J\_ominus}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the inverse pose compounding operation (\eqref{equation:Pose:eq-oplus}) with respect the pose \sphinxstyleemphasis{AxB} (the self object):
\begin{equation}\label{equation:Pose:eq-Jominus}
\begin{split}J_{\ominus}=\frac{\partial  \ominus ^Ax_B}{\partial ^Ax_B}\end{split}
\end{equation}
\sphinxAtStartPar
Returns the numerical matrix containing the evaluation of the Jacobian for the pose \sphinxstyleemphasis{AxB} (the self object).
\sphinxstylestrong{This is a pure virtual method that must be implemented by a child class.}
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Evaluation of the \(J_{\ominus}\) Jacobian of the inverse pose compounding operation with respect to the pose (eq. \eqref{equation:Pose:eq-Jominus3dof})

\end{description}\end{quote}

\end{fulllineitems}

\index{boxplus() (Pose.Pose method)@\spxentry{boxplus()}\spxextra{Pose.Pose method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Pose:Pose.Pose.boxplus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{boxplus}}}{\sphinxparam{\DUrole{n}{BxF}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Given a Pose object \sphinxstyleemphasis{NxB} (the self object) and a Feature object \sphinxstyleemphasis{BxF}, it returns the Feature object \sphinxstyleemphasis{NxF}
providing the same feature but now expresend in the N\sphinxhyphen{}Frame.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{BxF}} \textendash{} Feature object expressed in the B\sphinxhyphen{}Frame

\sphinxlineitem{Returns}
\sphinxAtStartPar
NxF Feature object expressed in the N\sphinxhyphen{}Frame

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_1boxplus() (Pose.Pose method)@\spxentry{J\_1boxplus()}\spxextra{Pose.Pose method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Pose:Pose.Pose.J_1boxplus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{J\_1boxplus}}}{\sphinxparam{\DUrole{n}{BxF}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the pose\sphinxhyphen{}feature compounding operation (eq. \eqref{equation:Feature:eq-boxplus}) with respect to the robot pose:
\begin{equation}\label{equation:Pose:eq-J1boxplus}
\begin{split}J_{1\boxplus}=\frac{\partial  ^Nx_B \boxplus ^Bx_F}{\partial ^Nx_B}\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{BxF}} \textendash{} Feature object expressed in the B\sphinxhyphen{}Frame

\sphinxlineitem{Returns}
\sphinxAtStartPar
\(J_{1\boxplus}\) Jacobian of the feature compounding operation with respect to the robot pose (eq. \eqref{equation:Pose:eq-J1boxplus})

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_2boxplus() (Pose.Pose method)@\spxentry{J\_2boxplus()}\spxextra{Pose.Pose method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Pose:Pose.Pose.J_2boxplus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{J\_2boxplus}}}{\sphinxparam{\DUrole{n}{BxF}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the pose\sphinxhyphen{}feature compounding operation (eq. \eqref{equation:Feature:eq-boxplus}) with respect to the feature:
\begin{equation}\label{equation:Pose:eq-J2boxplus}
\begin{split}J_{2\boxplus}=\frac{\partial  ^Nx_B \boxplus ^Bx_F}{\partial ^Bx_F}\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{BxF}} \textendash{} Feature object expressed in the B\sphinxhyphen{}Frame

\sphinxlineitem{Returns}
\sphinxAtStartPar
\(J_{2\boxplus}\) Jacobian of the feature compounding operation with respect to the feature (eq. \eqref{equation:Pose:eq-J2boxplus})

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Pose 3DOF}
\label{\detokenize{Pose:pose-3dof}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{Pose3D}.png}
\end{figure}
\index{Pose3D (class in Pose)@\spxentry{Pose3D}\spxextra{class in Pose}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Pose:Pose.Pose3D}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{Pose.}}\sphinxbfcode{\sphinxupquote{Pose3D}}}{\sphinxparam{\DUrole{n}{input\_array}\DUrole{o}{=}\DUrole{default_value}{array({[}{[}0.{]}, {[}0.{]}, {[}0.{]}{]})}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{Pose:Pose.Pose}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Pose}}}}}

\sphinxAtStartPar
Definition of a robot pose in 3 DOF (x, y, yaw). The class inherits from a ndarray.
This class extends the ndarray with the \(oplus\) and \(ominus\) operators and the corresponding Jacobians.
\index{\_\_init\_\_() (Pose.Pose3D method)@\spxentry{\_\_init\_\_()}\spxextra{Pose.Pose3D method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Pose:Pose.Pose3D.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{n}{input\_array}\DUrole{o}{=}\DUrole{default_value}{array({[}{[}0.{]}, {[}0.{]}, {[}0.{]}{]})}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{oplus() (Pose.Pose3D method)@\spxentry{oplus()}\spxextra{Pose.Pose3D method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Pose:Pose.Pose3D.oplus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{oplus}}}{\sphinxparam{\DUrole{n}{BxC}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Given a Pose3D object \sphinxstyleemphasis{AxB} (the self object) and a Pose3D object \sphinxstyleemphasis{BxC}, it returns the Pose3D object \sphinxstyleemphasis{AxC}.
\begin{equation*}
\begin{split}\mathbf{{^A}x_B} &= \begin{bmatrix} ^Ax_B & ^Ay_B & ^A\psi_B \end{bmatrix}^T \\
\mathbf{{^B}x_C} &= \begin{bmatrix} ^Bx_C & ^By_C & & ^B\psi_C \end{bmatrix}^T \\\end{split}
\end{equation*}
\sphinxAtStartPar
The operation is defined as:
\begin{equation}\label{equation:Pose:eq-oplus3dof}
\begin{split}\mathbf{{^A}x_C} &= \mathbf{{^A}x_B} \oplus \mathbf{{^B}x_C} =
\begin{bmatrix}
    ^Ax_B + ^Bx_C  \cos(^A\psi_B) - ^By_C  \sin(^A\psi_B) \\
    ^Ay_B + ^Bx_C  \sin(^A\psi_B) + ^By_C  \cos(^A\psi_B) \\
    ^A\psi_B + ^B\psi_C
\end{bmatrix}\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{BxC}} \textendash{} C\sphinxhyphen{}Frame pose expressed in B\sphinxhyphen{}Frame coordinates

\sphinxlineitem{Returns}
\sphinxAtStartPar
C\sphinxhyphen{}Frame pose expressed in A\sphinxhyphen{}Frame coordinates

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_1oplus() (Pose.Pose3D method)@\spxentry{J\_1oplus()}\spxextra{Pose.Pose3D method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Pose:Pose.Pose3D.J_1oplus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{J\_1oplus}}}{\sphinxparam{\DUrole{n}{BxC}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the pose compounding operation (eq. \eqref{equation:Pose:eq-oplus3dof}) with respect to the first pose:
\begin{equation}\label{equation:Pose:eq-J1oplus3dof}
\begin{split}J_{1\oplus}=\frac{\partial  ^Ax_B \oplus ^Bx_C}{\partial ^Ax_B} =
\begin{bmatrix}
    1 & 0 &  -^Bx_C \sin(^A\psi_B) - ^By_C \cos(^A\psi_B) \\
    0 & 1 &  ^Bx_C \cos(^A\psi_B) - ^By_C \sin(^A\psi_B) \\
    0 & 0 & 1
\end{bmatrix}\end{split}
\end{equation}
\sphinxAtStartPar
The method returns a numerical matrix containing the evaluation of the Jacobian for the pose \sphinxstyleemphasis{AxB} (the self object) and the \(2^{nd}\) posepose \sphinxstyleemphasis{BxC}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{BxC}} \textendash{} 2nd pose

\sphinxlineitem{Returns}
\sphinxAtStartPar
Evaluation of the \(J_{1\oplus}\) Jacobian of the pose compounding operation with respect to the first pose (eq. \eqref{equation:Pose:eq-J1oplus3dof})

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_2oplus() (Pose.Pose3D method)@\spxentry{J\_2oplus()}\spxextra{Pose.Pose3D method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Pose:Pose.Pose3D.J_2oplus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{J\_2oplus}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the pose compounding operation (\eqref{equation:Pose:eq-oplus3dof}) with respect to the second pose:
\begin{equation}\label{equation:Pose:eq-J2oplus3dof}
\begin{split}J_{2\oplus}=\frac{\partial  ^Ax_B \oplus ^Bx_C}{\partial ^Bx_C} =
\begin{bmatrix}
    \cos(^A\psi_B) & -\sin(^A\psi_B) & 0  \\
    \sin(^A\psi_B) & \cos(^A\psi_B) & 0  \\
    0 & 0 & 1
\end{bmatrix}\end{split}
\end{equation}
\sphinxAtStartPar
The method returns a numerical matrix containing the evaluation of the Jacobian for the :math:{\color{red}\bfseries{}\textasciigrave{}}1\textasciicircum{}\{st\} posepose \sphinxstyleemphasis{AxB} (the self object).
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Evaluation of the \(J_{2\oplus}\) Jacobian of the pose compounding operation with respect to the second pose (eq. \eqref{equation:Pose:eq-J2oplus3dof})

\end{description}\end{quote}

\end{fulllineitems}

\index{ominus() (Pose.Pose3D method)@\spxentry{ominus()}\spxextra{Pose.Pose3D method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Pose:Pose.Pose3D.ominus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ominus}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Inverse pose compounding of the \sphinxstyleemphasis{AxB} pose (the self objetc):
\begin{equation}\label{equation:Pose:eq-ominus3dof}
\begin{split}^Bx_A = \ominus ^Ax_B =
\begin{bmatrix}
    -^Ax_B \cos(^A\psi_B) - ^Ay_B \sin(^A\psi_B) \\
    ^Ax_B \sin(^A\psi_B) - ^Ay_B \cos(^A\psi_B) \\
    -^A\psi_B
\end{bmatrix}\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
A\sphinxhyphen{}Frame pose expressed in B\sphinxhyphen{}Frame coordinates (eq. \eqref{equation:Pose:eq-ominus3dof})

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_ominus() (Pose.Pose3D method)@\spxentry{J\_ominus()}\spxextra{Pose.Pose3D method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Pose:Pose.Pose3D.J_ominus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{J\_ominus}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the inverse pose compounding operation (\eqref{equation:Pose:eq-oplus3dof}) with respect the pose \sphinxstyleemphasis{AxB} (the self object):
\begin{equation}\label{equation:Pose:eq-Jominus3dof}
\begin{split}J_{\ominus}=\frac{\partial  \ominus ^Ax_B}{\partial ^Ax_B} =
\begin{bmatrix}
    -\cos(^A\psi_B) & -\sin(^A\psi_B) &  ^Ax_B \sin(^A\psi_B) - ^Ay_B \cos(^A\psi_B) \\
    \sin(^A\psi_B) & -\cos(^A\psi_B) &  ^Ax_B \cos(^A\psi_B) + ^Ay_B \sin(^A\psi_B) \\
    0 & 0 & -1
\end{bmatrix}\end{split}
\end{equation}
\sphinxAtStartPar
Returns the numerical matrix containing the evaluation of the Jacobian for the pose \sphinxstyleemphasis{AxB} (the self object).
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Evaluation of the \(J_{\ominus}\) Jacobian of the inverse pose compounding operation with respect to the pose (eq. \eqref{equation:Pose:eq-Jominus3dof})

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Pose 4DOF}
\label{\detokenize{Pose:pose-4dof}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{Pose4D}.png}
\end{figure}
\index{Pose4D (class in Pose)@\spxentry{Pose4D}\spxextra{class in Pose}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Pose:Pose.Pose4D}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{Pose.}}\sphinxbfcode{\sphinxupquote{Pose4D}}}{\sphinxparam{\DUrole{n}{input\_array}\DUrole{o}{=}\DUrole{default_value}{array({[}{[}0.{]}, {[}0.{]}, {[}0.{]}, {[}0.{]}{]})}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{Pose:Pose.Pose}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Pose}}}}}

\sphinxAtStartPar
Definition of a robot pose in 4 DOF (x, y, yaw). The class inherits from a ndarray.
This class extends the ndarray with the \(oplus\) and :math:{\color{red}\bfseries{}\textasciigrave{}}ominus operators and the corresponding Jacobians.
\index{\_\_init\_\_() (Pose.Pose4D method)@\spxentry{\_\_init\_\_()}\spxextra{Pose.Pose4D method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Pose:Pose.Pose4D.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{n}{input\_array}\DUrole{o}{=}\DUrole{default_value}{array({[}{[}0.{]}, {[}0.{]}, {[}0.{]}, {[}0.{]}{]})}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{oplus() (Pose.Pose4D method)@\spxentry{oplus()}\spxextra{Pose.Pose4D method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Pose:Pose.Pose4D.oplus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{oplus}}}{\sphinxparam{\DUrole{n}{BxC}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Given a Pose3D object \sphinxstyleemphasis{AxB} (the self object) and a Pose3D object \sphinxstyleemphasis{BxC}, it returns the Pose4D object \sphinxstyleemphasis{AxC}.
\begin{equation}\label{equation:Pose:eq-oplus4dof}
\begin{split}^Ax_B &= \begin{bmatrix} ^Ax_B & ^Ay_B & ^Az_B & ^A\psi_B \end{bmatrix}^T \\
^Bx_C &= \begin{bmatrix} ^Bx_C & ^By_C & ^Bz_C & ^B\psi_C \end{bmatrix}^T \\
^Ax_C &= ^Ax_B \oplus ^Bx_C =
\begin{bmatrix}
    ^Ax_B + ^Bx_C  \cos(^A\psi_B) - ^By_C  \sin(^A\psi_B) \\
    ^Ay_B + ^Bx_C  \sin(^A\psi_B) + ^By_C  \cos(^A\psi_B) \\
    ^Az_B + ^Bz_C \\
    ^A\psi_B + ^B\psi_C
\end{bmatrix}\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{BxC}} \textendash{} C\sphinxhyphen{}Frame pose expressed in B\sphinxhyphen{}Frame coordinates

\sphinxlineitem{Returns}
\sphinxAtStartPar
C\sphinxhyphen{}Frame pose expressed in A\sphinxhyphen{}Frame coordinates

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_1oplus() (Pose.Pose4D method)@\spxentry{J\_1oplus()}\spxextra{Pose.Pose4D method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Pose:Pose.Pose4D.J_1oplus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{J\_1oplus}}}{\sphinxparam{\DUrole{n}{BxC}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the pose compounding operation (eq. \eqref{equation:Pose:eq-oplus4dof}) with respect to the first pose:
\begin{equation}\label{equation:Pose:eq-J1oplus4dof}
\begin{split}J_{1\oplus}=\frac{\partial  ^Ax_B \oplus ^Bx_C}{\partial ^Ax_B} =
\begin{bmatrix}
    1 & 0 & 0 & -^Bx_C \sin(^A\psi_B) - ^By_C \cos(^A\psi_B) \\
    0 & 1 & 0 & ^Bx_C \cos(^A\psi_B) - ^By_C \sin(^A\psi_B) \\
    0 & 0 & 1 & 0 \\
    0 & 0 & 0 & 1
\end{bmatrix}\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{AxB}} \textendash{} first pose

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{BxC}} \textendash{} 2nd pose

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\(J_{1\oplus}\) Jacobian of the pose compounding operation with respect to the first pose (eq. \eqref{equation:Pose:eq-J1oplus4dof})

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_2oplus() (Pose.Pose4D method)@\spxentry{J\_2oplus()}\spxextra{Pose.Pose4D method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Pose:Pose.Pose4D.J_2oplus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{J\_2oplus}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the pose compounding operation (\eqref{equation:Pose:eq-oplus4dof}) with respect to the second pose:
\begin{equation}\label{equation:Pose:eq-J2oplus4dof}
\begin{split}J_{2\oplus}=\frac{\partial  ^Ax_B \oplus ^Bx_C}{\partial ^Bx_C} =
\begin{bmatrix}
    \cos(^A\psi_B) & -\sin(^A\psi_B) & 0 & 0 \\
    \sin(^A\psi_B) & \cos(^A\psi_B) & 0 & 0 \\
    0 & 0 & 1 & 0 \\
    0 & 0 & 0 & 1
\end{bmatrix}\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{AxB}} \textendash{} first pose

\sphinxlineitem{Returns}
\sphinxAtStartPar
\(J_{2\oplus}\) Jacobian of the pose compounding operation with respect to the second pose (eq. \eqref{equation:Pose:eq-J2oplus4dof})

\end{description}\end{quote}

\end{fulllineitems}

\index{ominus() (Pose.Pose4D method)@\spxentry{ominus()}\spxextra{Pose.Pose4D method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Pose:Pose.Pose4D.ominus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ominus}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Inverse pose compounding of the \sphinxstyleemphasis{AxB} pose (the self object):
\begin{equation}\label{equation:Pose:eq-ominus4dof}
\begin{split}^Bx_A = \ominus ^Ax_B =
\begin{bmatrix}
    -^Ax_B \cos(^A\psi_B) - ^Ay_B \sin(^A\psi_B) \\
    ^Ax_B \sin(^A\psi_B) - ^Ay_B \cos(^A\psi_B) \\
    -^Az_B \\
    -^A\psi_B
\end{bmatrix}\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{AxB}} \textendash{} B\sphinxhyphen{}Frame pose expressed in A\sphinxhyphen{}Frame coordinates

\sphinxlineitem{Returns}
\sphinxAtStartPar
A\sphinxhyphen{}Frame pose expressed in B\sphinxhyphen{}Frame coordinates (eq. \eqref{equation:Pose:eq-ominus4dof}

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_ominus() (Pose.Pose4D method)@\spxentry{J\_ominus()}\spxextra{Pose.Pose4D method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Pose:Pose.Pose4D.J_ominus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{J\_ominus}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the inverse pose compounding operation (\eqref{equation:Pose:eq-oplus4dof}) with respect the pose \sphinxstyleemphasis{AxB} (the self object):
\begin{equation}\label{equation:Pose:eq-Jominus4dof}
\begin{split}J_{\ominus}=\frac{\partial  \ominus ^Ax_B}{\partial ^Ax_B} =
\begin{bmatrix}
    -\cos(^A\psi_B) & -\sin(^A\psi_B) & 0 & ^Ax_B \sin(^A\psi_B) - ^Ay_B \cos(^A\psi_B) \\
    \sin(^A\psi_B) & -\cos(^A\psi_B) & 0 & ^Ax_B \cos(^A\psi_B) + ^Ay_B \sin(^A\psi_B) \\
    0 & 0 & -1 & ^Az_B \\
    0 & 0 & 0 & -1
\end{bmatrix}\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{AxB}} \textendash{} B\sphinxhyphen{}Fram pose expressed in A\sphinxhyphen{}Frame coordinates

\sphinxlineitem{Returns}
\sphinxAtStartPar
\(J_{\ominus}\) Jacobian of the inverse pose compounding operation with respect to the pose (eq. \eqref{equation:Pose:eq-Jominus4dof})

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\section{Feature Representation}
\label{\detokenize{Feature:feature-representation}}\label{\detokenize{Feature::doc}}

\subsection{Feature}
\label{\detokenize{Feature:feature}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{Feature}.png}
\end{figure}
\index{Feature (class in Feature)@\spxentry{Feature}\spxextra{class in Feature}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Feature:Feature.Feature}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{Feature.}}\sphinxbfcode{\sphinxupquote{Feature}}}{\sphinxparam{\DUrole{n}{feature}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
This class implements the \sphinxstylestrong{interface of the pose\sphinxhyphen{}feature compounding operation}. This class provides the interface
to implement the compounding operation between the robot pose (represented in the N\sphinxhyphen{}Frame) and the feature pose (represented in
the B\sphinxhyphen{}Frame) obtaining the feature representation in the N\sphinxhyphen{}Frame.
The class also provides the interface to implement the Jacobians of the pose\sphinxhyphen{}feature compounding operation.
\index{\_\_init\_\_() (Feature.Feature method)@\spxentry{\_\_init\_\_()}\spxextra{Feature.Feature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Feature:Feature.Feature.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{n}{feature}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{boxplus() (Feature.Feature method)@\spxentry{boxplus()}\spxextra{Feature.Feature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Feature:Feature.Feature.boxplus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{boxplus}}}{\sphinxparam{\DUrole{n}{NxB}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Pose\sphinxhyphen{}Feature compounding operation:
\begin{equation}\label{equation:Feature:eq-boxplus}
\begin{split}^Nx_F=^Nx_B \boxplus ^Bx_F\end{split}
\end{equation}
\sphinxAtStartPar
which computes the pose of a feature in the N\sphinxhyphen{}Frame given the pose of the robot in the N\sphinxhyphen{}Frame and the pose of
the feature in the B\sphinxhyphen{}Frame.
\sphinxstylestrong{This is a pure virtual method that must be overwritten by the child class}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{NxB}} \textendash{} Robot pose in the N\sphinxhyphen{}Frame (\(^Nx_B\))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{BxF}} \textendash{} Feature pose in the B\sphinxhyphen{}Frame (\(^Bx_F\))

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Feature pose in the N\sphinxhyphen{}Frame (\(^Nx_F\))

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_1boxplus() (Feature.Feature method)@\spxentry{J\_1boxplus()}\spxextra{Feature.Feature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Feature:Feature.Feature.J_1boxplus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{J\_1boxplus}}}{\sphinxparam{\DUrole{n}{NxB}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the Pose\sphinxhyphen{}Feature compounding operation (eq. \eqref{equation:Feature:eq-boxplus}) with respect to the first argument \(^Nx_B\).
\begin{equation}\label{equation:Feature:eq-boxplus}
\begin{split}J_{1\boxplus}=\frac{\partial ^Nx_B \boxplus ^Bx_F}{\partial ^Nx_B}.\end{split}
\end{equation}
\sphinxAtStartPar
\sphinxstylestrong{To be overriden by the child class}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{NxB}} \textendash{} Robot pose in the N\sphinxhyphen{}Frame (\(^Nx_B\))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{BxF}} \textendash{} Feature pose in the B\sphinxhyphen{}Frame (\(^Bx_F\))

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian matrix \(J_{1\boxplus}\)

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_2boxplus() (Feature.Feature method)@\spxentry{J\_2boxplus()}\spxextra{Feature.Feature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Feature:Feature.Feature.J_2boxplus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{J\_2boxplus}}}{\sphinxparam{\DUrole{n}{NxB}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the Pose\sphinxhyphen{}Feature compounding operation (eq. \eqref{equation:Feature:eq-boxplus}) with respect to the second argument \(^Bx_F\).
\begin{equation}\label{equation:Feature:eq-boxplus}
\begin{split}J_{2\boxplus}=\frac{\partial ^Nx_B \boxplus ^Bx_F}{\partial ^Bx_F}.\end{split}
\end{equation}
\sphinxAtStartPar
\sphinxstylestrong{To be overriden by the child class}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{NxB}} \textendash{} Robot pose in the N\sphinxhyphen{}Frame (\(^Nx_B\))

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian matrix \(J_{2\boxplus}\)

\end{description}\end{quote}

\end{fulllineitems}

\index{ToCartesian() (Feature.Feature method)@\spxentry{ToCartesian()}\spxextra{Feature.Feature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Feature:Feature.Feature.ToCartesian}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ToCartesian}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Translates from its internal representation to the representation used for plotting.
\sphinxstylestrong{To be overriden by the child class}.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Feature in Cartesian Coordinates

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_2c() (Feature.Feature method)@\spxentry{J\_2c()}\spxextra{Feature.Feature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Feature:Feature.Feature.J_2c}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{J\_2c}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the ToCartesian method. Required for plotting non Cartesian features.
\sphinxstylestrong{To be overriden by the child class}.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian of the transformation

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Cartesian Feature}
\label{\detokenize{Feature:cartesian-feature}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{CartesianFeature}.png}
\end{figure}
\index{CartesianFeature (class in Feature)@\spxentry{CartesianFeature}\spxextra{class in Feature}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Feature:Feature.CartesianFeature}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{Feature.}}\sphinxbfcode{\sphinxupquote{CartesianFeature}}}{\sphinxparam{\DUrole{n}{input\_array}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{Feature:Feature.Feature}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Feature}}}}}, \sphinxcode{\sphinxupquote{ndarray}}

\sphinxAtStartPar
Cartesian feature class. The class inherits from the {\hyperref[\detokenize{Feature:Feature.Feature}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Feature}}}}} class providing an implementation of its
interface for a Cartesian Feature, by implementing the \(\boxplus\) operator as well as its Jacobians. The
class also inherits from the ndarray numpy class allowing to be operated as a numpy ndarray.
\index{boxplus() (Feature.CartesianFeature method)@\spxentry{boxplus()}\spxextra{Feature.CartesianFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Feature:Feature.CartesianFeature.boxplus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{boxplus}}}{\sphinxparam{\DUrole{n}{NxB}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Pose\sphinxhyphen{}Cartesian Feature compounding operation:
\begin{equation}\label{equation:Feature:eq-boxplus2DCartesian}
\begin{split}F&=\begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \end{bmatrix}\\
^Nx_F&=^Nx_B \boxplus ^Bx_F = F ( ^Nx_B \oplus ^Bx_F )\end{split}
\end{equation}
\sphinxAtStartPar
which computes the Cartesian position of a feature in the N\sphinxhyphen{}Frame given the pose of the robot in the N\sphinxhyphen{}Frame and
the Cartesian position of the feature in the B\sphinxhyphen{}Frame.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{NxB}} \textendash{} Robot pose in the N\sphinxhyphen{}Frame (\(^Nx_B\))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{BxF}} \textendash{} Cartesian feature pose in the B\sphinxhyphen{}Frame (\(^Bx_F\))

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Feature pose in the N\sphinxhyphen{}Frame (\(^Nx_F\))

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_1boxplus() (Feature.CartesianFeature method)@\spxentry{J\_1boxplus()}\spxextra{Feature.CartesianFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Feature:Feature.CartesianFeature.J_1boxplus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{J\_1boxplus}}}{\sphinxparam{\DUrole{n}{NxB}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the Pose\sphinxhyphen{}Cartesian Feature compounding operation with respect to the robot pose:
\begin{equation}\label{equation:Feature:eq-J1boxplus2DCartesian}
\begin{split}J_{1\boxplus} = F J_{1\oplus}\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{NxB}} \textendash{} robot pose represented in the N\sphinxhyphen{}Frame (\(^Nx_B\))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{BxF}} \textendash{} Cartesian feature pose represented in the B\sphinxhyphen{}Frame (\(^Bx_F\))

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian matrix \(J_{\1boxplus}\) (eq. \eqref{equation:Feature:eq-J1boxplus2DCartesian}) (eq. \eqref{equation:Feature:eq-J1boxplus2DCartesian})

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_2boxplus() (Feature.CartesianFeature method)@\spxentry{J\_2boxplus()}\spxextra{Feature.CartesianFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Feature:Feature.CartesianFeature.J_2boxplus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{J\_2boxplus}}}{\sphinxparam{\DUrole{n}{NxB}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the Pose\sphinxhyphen{}Cartesian Feature compounding operation with respect to the feature position:
\begin{equation}\label{equation:Feature:eq-J2boxplus2DCartesian}
\begin{split}J_{2\boxplus} = F J_{2oplus}\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{NxB}} \textendash{} robot pose represented in the N\sphinxhyphen{}Frame (\(^Nx_B\))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{BxF}} \textendash{} Cartesian feature pose represented in the B\sphinxhyphen{}Frame (\(^Bx_F\))

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian matrix \(J_{1\boxplus}\) (eq. \eqref{equation:Feature:eq-J2boxplus2DCartesian})

\end{description}\end{quote}

\end{fulllineitems}

\index{ToCartesian() (Feature.CartesianFeature method)@\spxentry{ToCartesian()}\spxextra{Feature.CartesianFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Feature:Feature.CartesianFeature.ToCartesian}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ToCartesian}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Translates from its internal representation to the representation used for plotting.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Feature in Cartesian Coordinates

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_2c() (Feature.CartesianFeature method)@\spxentry{J\_2c()}\spxextra{Feature.CartesianFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Feature:Feature.CartesianFeature.J_2c}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{J\_2c}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the ToCartesian method. Required for plotting non Cartesian features.
\sphinxstylestrong{To be overriden by the child class}.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian of the transformation

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Polar Feature}
\label{\detokenize{Feature:polar-feature}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{PolarFeature}.png}
\end{figure}
\index{PolarFeature (class in Feature)@\spxentry{PolarFeature}\spxextra{class in Feature}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Feature:Feature.PolarFeature}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{Feature.}}\sphinxbfcode{\sphinxupquote{PolarFeature}}}{\sphinxparam{\DUrole{n}{input\_array}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{Feature:Feature.CartesianFeature}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CartesianFeature}}}}}, \sphinxcode{\sphinxupquote{ndarray}}

\sphinxAtStartPar
Polar feature class. The class inherits from the {\hyperref[\detokenize{Feature:Feature.Feature}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Feature}}}}} class providing an implementation of its
interface for a Polar Feature, by implementing the \(\boxplus\) operator as well as its Jacobians. The
class also inherits from the ndarray numpy class allowing to be operated as a numpy ndarray.
\index{boxplus() (Feature.PolarFeature method)@\spxentry{boxplus()}\spxextra{Feature.PolarFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Feature:Feature.PolarFeature.boxplus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{boxplus}}}{\sphinxparam{\DUrole{n}{NxB}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Pose\sphinxhyphen{}Polar Feature compounding operation:
\begin{equation}\label{equation:Feature:eq-boxplus2DCartesian}
\begin{split}F&=\begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \end{bmatrix}\\
^Nx_F&=^Nx_B \boxplus ^Bx_F = F ( ^Nx_B \oplus ^Bx_F )\end{split}
\end{equation}
\sphinxAtStartPar
which computes the Polar pose of a feature in the N\sphinxhyphen{}Frame given the pose of the robot in the N\sphinxhyphen{}Frame and the
Polar pose of the feature in the B\sphinxhyphen{}Frame.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{NxB}} \textendash{} Robot pose in the N\sphinxhyphen{}Frame (\(^Nx_B\))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{BxF}} \textendash{} Polar feature pose in the B\sphinxhyphen{}Frame (\(^Bx_F\))

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Polar feature pose in the N\sphinxhyphen{}Frame (\(^Nx_F\))

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_1boxplus() (Feature.PolarFeature method)@\spxentry{J\_1boxplus()}\spxextra{Feature.PolarFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Feature:Feature.PolarFeature.J_1boxplus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{J\_1boxplus}}}{\sphinxparam{\DUrole{n}{NxB}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the Pose\sphinxhyphen{}Polar Feature compounding operation with respect to the robot pose:
\begin{equation}\label{equation:Feature:eq-J1boxplusPolar}
\begin{split}J_{1\boxplus} = F J_{1\oplus}\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{NxB}} \textendash{} robot pose represented in the N\sphinxhyphen{}Frame (\(^Nx_B\))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{BxF}} \textendash{} Polar eature pose represented in the B\sphinxhyphen{}Frame (\(^Bx_F\))

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian matrix \(J_{\1boxplus}\) (eq. \eqref{equation:Feature:eq-J1boxplusPolar})

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_2boxplus() (Feature.PolarFeature method)@\spxentry{J\_2boxplus()}\spxextra{Feature.PolarFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Feature:Feature.PolarFeature.J_2boxplus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{J\_2boxplus}}}{\sphinxparam{\DUrole{n}{NxB}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the Pose\sphinxhyphen{}Polar Feature compounding operation with respect to the feature pose:
\begin{equation}\label{equation:Feature:eq-J2boxplusPolar}
\begin{split}J_{2\boxplus} = F J_{2oplus}\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{NxB}} \textendash{} Robot pose represented in the N\sphinxhyphen{}Frame (\(^Nx_B\))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{BxF}} \textendash{} Polar feature pose represented in the B\sphinxhyphen{}Frame (\(^Bx_F\))

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian matrix \(J_{1\boxplus}\) (eq. \eqref{equation:Feature:eq-J2boxplusPolar})

\end{description}\end{quote}

\end{fulllineitems}

\index{ToCartesian() (Feature.PolarFeature method)@\spxentry{ToCartesian()}\spxextra{Feature.PolarFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Feature:Feature.PolarFeature.ToCartesian}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ToCartesian}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Translates from its internal representation to the representation used for plotting.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Feature in Cartesian Coordinates

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_2c() (Feature.PolarFeature method)@\spxentry{J\_2c()}\spxextra{Feature.PolarFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Feature:Feature.PolarFeature.J_2c}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{J\_2c}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the ToCartesian method. Required for plotting non Cartesian features.
\sphinxstylestrong{To be overriden by the child class}.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian of the transformation

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\section{Coordinate Conversion Functions}
\label{\detokenize{conversions:coordinate-conversion-functions}}\label{\detokenize{conversions::doc}}
\sphinxAtStartPar
This functions are used to convert between different coordinate systems (e.g. from cartesian to polar, from polar to
cartesian, etc.). The functions are implemented in a way that they can be used with numpy arrays. or each coordinate
conversion its Jacobian is also implemented.
This functions are required to convert from the observation space (the coordinates in which the features are observed)
to the storage space (the coordinates in which the features are stored in the map). For instance, if the features are
observed in polar coordinates, but stored in cartesian coordinates, the conversion from polar to cartesian is required.


\subsection{Polar To Cartesian}
\label{\detokenize{conversions:polar-to-cartesian}}\index{p2c() (in module conversions)@\spxentry{p2c()}\spxextra{in module conversions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{conversions:conversions.p2c}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{conversions.}}\sphinxbfcode{\sphinxupquote{p2c}}}{\sphinxparam{\DUrole{n}{p}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Converts from a 2D Polar coordinate to its corresponding 2D Cartesian coordinate:
\begin{equation}\label{equation:conversions:eq-p2c}
\begin{split}p & = \begin{bmatrix} \rho \\ \theta \end{bmatrix} \\
c &= p2c \left(\begin{bmatrix} x \\ y \end{bmatrix} =  \begin{bmatrix} \rho \cos(\theta) \\ \rho \sin(\theta) \end{bmatrix}\right)\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{p}} \textendash{} point in polar coordinates

\sphinxlineitem{Returns}
\sphinxAtStartPar
point in cartesian coordinates

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_p2c() (in module conversions)@\spxentry{J\_p2c()}\spxextra{in module conversions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{conversions:conversions.J_p2c}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{conversions.}}\sphinxbfcode{\sphinxupquote{J\_p2c}}}{\sphinxparam{\DUrole{n}{p}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the 2D Polar to cartesian conversion:
\begin{equation}\label{equation:conversions:eq-Jp2c}
\begin{split}J_{p2c} = \begin{bmatrix} \frac{\partial x}{\partial \rho} & \frac{\partial x}{\partial \theta} \\ \frac{\partial y}{\partial \rho} & \frac{\partial y}{\partial \theta} \end{bmatrix} = \begin{bmatrix} \cos(\theta) & -\rho \sin(\theta) \\ \sin(\theta) & \rho \cos(\theta) \end{bmatrix}\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{p}} \textendash{} linearization point in polar coordinates

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian matrix \(J_{p2c}\) (eq. \eqref{equation:conversions:eq-Jp2c})

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Cartesian To Polar}
\label{\detokenize{conversions:cartesian-to-polar}}\index{c2p() (in module conversions)@\spxentry{c2p()}\spxextra{in module conversions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{conversions:conversions.c2p}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{conversions.}}\sphinxbfcode{\sphinxupquote{c2p}}}{\sphinxparam{\DUrole{n}{c}}}{}
\pysigstopsignatures
\sphinxAtStartPar
2D Cartesian to polar conversion:
\begin{equation}\label{equation:conversions:eq-c2p}
\begin{split}c &= \begin{bmatrix} x \\ y \end{bmatrix} \\
p & = c2p\left(\begin{bmatrix} \rho \\ \theta \end{bmatrix} = \begin{bmatrix} \sqrt{x^2+y^2} \\ atan2(y,x) \end{bmatrix}\right)\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} point in cartesian coordinates

\sphinxlineitem{Returns}
\sphinxAtStartPar
point in polar coordinates

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_c2p() (in module conversions)@\spxentry{J\_c2p()}\spxextra{in module conversions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{conversions:conversions.J_c2p}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{conversions.}}\sphinxbfcode{\sphinxupquote{J\_c2p}}}{\sphinxparam{\DUrole{n}{c}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the 2D Cartesian to polar conversion:
\begin{equation}\label{equation:conversions:eq-Jc2p}
\begin{split}J_{c2p} = \begin{bmatrix} \frac{\partial \rho}{\partial x} & \frac{\partial \rho}{\partial y} \\ \frac{\partial \theta}{\partial x} & \frac{\partial \theta}{\partial y} \end{bmatrix} = \begin{bmatrix} \frac{x}{\sqrt{x^2+y^2}} & \frac{y}{\sqrt{x^2+y^2}} \\ -\frac{y}{x^2+y^2} & \frac{x}{x^2+y^2} \end{bmatrix}\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} point in cartesian coordinates

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian matrix \(J_{c2p}\) (eq. \eqref{equation:conversions:eq-Jc2p})

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Spherical To Cartesian}
\label{\detokenize{conversions:spherical-to-cartesian}}\index{s2c() (in module conversions)@\spxentry{s2c()}\spxextra{in module conversions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{conversions:conversions.s2c}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{conversions.}}\sphinxbfcode{\sphinxupquote{s2c}}}{\sphinxparam{\DUrole{n}{s}}}{}
\pysigstopsignatures
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=300\sphinxpxdimen]{{3D_Spherical}.png}\hspace*{\fill}}

\sphinxAtStartPar
3D Spherical to cartesian conversion:
\begin{equation}\label{equation:conversions:eq-s2c}
\begin{split}s & = \begin{bmatrix} \rho \\ \theta \\ \varphi \end{bmatrix} \\
c &= s2c \left(\begin{bmatrix} x \\ y \\ z \end{bmatrix} =  \begin{bmatrix} \rho \sin(\theta) \cos(\varphi) \\ \rho \sin(\theta) \sin(\varphi) \\ \rho \cos(\theta) \end{bmatrix}\right)\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{s}} \textendash{} point in spherical coordinates

\sphinxlineitem{Returns}
\sphinxAtStartPar
point in cartesian coordinates

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_s2c() (in module conversions)@\spxentry{J\_s2c()}\spxextra{in module conversions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{conversions:conversions.J_s2c}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{conversions.}}\sphinxbfcode{\sphinxupquote{J\_s2c}}}{\sphinxparam{\DUrole{n}{s}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the 3D Spherical to cartesian conversion:
\begin{equation}\label{equation:conversions:eq-Js2c}
\begin{split}J_{s2c} = \begin{bmatrix} \frac{\partial x}{\partial \rho} & \frac{\partial x}{\partial \theta} & \frac{\partial x}{\partial \varphi} \\ \frac{\partial y}{\partial \rho} & \frac{\partial y}{\partial \theta} & \frac{\partial y}{\partial \varphi} \\ \frac{\partial z}{\partial \rho} & \frac{\partial z}{\partial \theta} & \frac{\partial z}{\partial \varphi} \end{bmatrix} = \begin{bmatrix} \sin(\theta)\cos(\varphi) & \rho\cos(\theta)\cos(\varphi) & -\rho\sin(\theta)\sin(\varphi) \\ \sin(\theta)\sin(\varphi) & \rho\cos(\theta)\sin(\varphi) & \rho\sin(\theta)\cos(\varphi) \\ \cos(\theta) & -\rho\sin(\theta) & 0 \end{bmatrix}\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{s}} \textendash{} linearization point in spherical coordinates

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian matrix \(J_{s2c}\) (eq. \eqref{equation:conversions:eq-Js2c})

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Cartesian To Spherical}
\label{\detokenize{conversions:cartesian-to-spherical}}\index{c2s() (in module conversions)@\spxentry{c2s()}\spxextra{in module conversions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{conversions:conversions.c2s}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{conversions.}}\sphinxbfcode{\sphinxupquote{c2s}}}{\sphinxparam{\DUrole{n}{c}}}{}
\pysigstopsignatures
\sphinxAtStartPar
3D Cartesian to spherical conversion:
\begin{equation}\label{equation:conversions:eq-c2s}
\begin{split}c &= \begin{bmatrix} x \\ y \\ z \end{bmatrix} \\
s & = c2s \left(\begin{bmatrix} \rho \\ \theta \\ \varphi \end{bmatrix} = \begin{bmatrix} \sqrt{x^2+y^2+z^2} \\ atan2(\sqrt{x^2+y^2},{z}) \\ atan2({y},{x}) \end{bmatrix}\right)\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} point in cartesian coordinates

\sphinxlineitem{Returns}
\sphinxAtStartPar
point in spherical coordinates

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_c2s() (in module conversions)@\spxentry{J\_c2s()}\spxextra{in module conversions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{conversions:conversions.J_c2s}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{conversions.}}\sphinxbfcode{\sphinxupquote{J\_c2s}}}{\sphinxparam{\DUrole{n}{c}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the 3D Cartesian to spherical conversion:
\begin{equation}\label{equation:conversions:eq-Jc2s}
\begin{split}J_{c2s} = \begin{bmatrix} \frac{\partial \rho}{\partial x} & \frac{\partial \rho}{\partial y} & \frac{\partial \rho}{\partial z} \\ \frac{\partial \theta}{\partial x} & \frac{\partial \theta}{\partial y} & \frac{\partial \theta}{\partial z} \\ \frac{\partial \varphi}{\partial x} & \frac{\partial \varphi}{\partial y} & \frac{\partial \varphi}{\partial z} \end{bmatrix} = \begin{bmatrix} \frac{x}{\sqrt{x^2+y^2+z^2}} & \frac{y}{\sqrt{x^2+y^2+z^2}} & \frac{z}{\sqrt{x^2+y^2+z^2}} \\ \frac{y}{x^2+y^2} & \frac{x}{x^2+y^2} & 0 \\ \frac{-x z}{(x^2+y^2)\sqrt{x^2+y^2}} & \frac{-y z}{(x^2+y^2)\sqrt{x^2+y^2}} & \frac{\sqrt{x^2+y^2}}{x^2+y^2} \end{bmatrix}\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} linearization point in cartesian coordinates

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian matrix \(J_{c2s}\) (eq. \eqref{equation:conversions:eq-Jc2s})

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Identity Conversion}
\label{\detokenize{conversions:identity-conversion}}\index{v2v() (in module conversions)@\spxentry{v2v()}\spxextra{in module conversions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{conversions:conversions.v2v}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{conversions.}}\sphinxbfcode{\sphinxupquote{v2v}}}{\sphinxparam{\DUrole{n}{v}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Identity transformation. Returns the same vector.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{v}} \textendash{} input vector

\sphinxlineitem{Returns}
\sphinxAtStartPar
output vector

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_v2v() (in module conversions)@\spxentry{J\_v2v()}\spxextra{in module conversions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{conversions:conversions.J_v2v}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{conversions.}}\sphinxbfcode{\sphinxupquote{J\_v2v}}}{\sphinxparam{\DUrole{n}{v}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the identity transformation. Returns the identity matrix of the same dimensionality as the input vector.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{v}} \textendash{} input vector

\sphinxlineitem{Returns}
\sphinxAtStartPar
Identity matrix of the same dimensionality as the input vector.

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\section{Robot Simulation}
\label{\detokenize{robot_simulation:robot-simulation}}\label{\detokenize{robot_simulation::doc}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.75]{{SimulatedRobot}.png}
\caption{SimulatedRobot Class Diagram.}\label{\detokenize{robot_simulation:id1}}\end{figure}
\index{SimulatedRobot (class in SimulatedRobot)@\spxentry{SimulatedRobot}\spxextra{class in SimulatedRobot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:SimulatedRobot.SimulatedRobot}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{SimulatedRobot.}}\sphinxbfcode{\sphinxupquote{SimulatedRobot}}}{\sphinxparam{\DUrole{n}{xs0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{map}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
This is the base class to simulate a robot. There are two operative frames: the world  N\sphinxhyphen{}Frame (North East Down oriented) and the robot body frame body B\sphinxhyphen{}Frame.
Each robot has a motion model and a measurement model. The motion model is used to simulate the robot motion and the measurement model is used to simulate the robot measurements.

\sphinxAtStartPar
\sphinxstylestrong{All Robot simulation classes must derive from this class} .
\index{dt (SimulatedRobot.SimulatedRobot attribute)@\spxentry{dt}\spxextra{SimulatedRobot.SimulatedRobot attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:SimulatedRobot.SimulatedRobot.dt}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{dt}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }0.1}}}
\pysigstopsignatures
\sphinxAtStartPar
class attribute containing sample time of the simulation

\end{fulllineitems}

\index{\_\_init\_\_() (SimulatedRobot.SimulatedRobot method)@\spxentry{\_\_init\_\_()}\spxextra{SimulatedRobot.SimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:SimulatedRobot.SimulatedRobot.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{n}{xs0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{map}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xs0}} \textendash{} initial simulated robot state \(x_{s_0}\) used to initialize the the motion model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{map}} \textendash{} feature map of the environment \(M=[^Nx_{F_1}^T,...,^Nx_{F_{nf}}^T]^T\)

\end{itemize}

\end{description}\end{quote}

\sphinxAtStartPar
Constructor. First, it initializes the robot simulation defining the following attributes:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{k} : time step

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Qsk} : \sphinxstylestrong{To be defined in the derived classes}. Object attribute containing Covariance of the simulation motion model noise

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{usk} : \sphinxstylestrong{To be defined in the derived classes}. Object attribute contining the simulated input to the motion model

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{xsk} : \sphinxstylestrong{To be defined in the derived classes}. Object attribute contining the current simulated robot state

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{zsk} : \sphinxstylestrong{To be defined in the derived classes}. Object attribute contining the current simulated robot measurement

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Rsk} : \sphinxstylestrong{To be defined in the derived classes}. Object attribute contining the observation noise covariance matrix

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{xsk} : current pose is the initial state

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{xsk\_1} : previouse state is the initial robot state

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{M} : position of the features in the N\sphinxhyphen{}Frame

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{nf} : number of features

\end{itemize}

\sphinxAtStartPar
Then, the robot animation is initialized defining the following attributes:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{vehicleIcon} : Path file of the image of the robot to be used in the animation

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{vehicleFig} : Figure of the robot to be used in the animation

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{vehicleAxes} : Axes of the robot to be used in the animation

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{xTraj} : list containing the x coordinates of the robot trajectory

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{yTraj} : list containing the y coordinates of the robot trajectory

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{visualizationInterval} : time\sphinxhyphen{}steps interval between two consecutive frames of the animation

\end{itemize}

\end{fulllineitems}

\index{PlotRobot() (SimulatedRobot.SimulatedRobot method)@\spxentry{PlotRobot()}\spxextra{SimulatedRobot.SimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:SimulatedRobot.SimulatedRobot.PlotRobot}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{PlotRobot}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Updates the plot of the robot at the current pose

\end{fulllineitems}

\index{fs() (SimulatedRobot.SimulatedRobot method)@\spxentry{fs()}\spxextra{SimulatedRobot.SimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:SimulatedRobot.SimulatedRobot.fs}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fs}}}{\sphinxparam{\DUrole{n}{xsk\_1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{usk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Motion model used to simulate the robot motion. Computes the current robot state \(x_k\) given the previous robot state \(x_{k-1}\) and the input \(u_k\).
It also updates the object attributes \(xsk\), \(xsk_1\) and  \(usk\) to be made them available for plotting purposes.
\sphinxstyleemphasis{To be overriden in child class}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xsk\_1}} \textendash{} previous robot state \(x_{k-1}\)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{usk}} \textendash{} model input \(u_{s_k}\)

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
current robot state \(x_k\)

\end{description}\end{quote}

\end{fulllineitems}

\index{SetMap() (SimulatedRobot.SimulatedRobot method)@\spxentry{SetMap()}\spxextra{SimulatedRobot.SimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:SimulatedRobot.SimulatedRobot.SetMap}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{SetMap}}}{\sphinxparam{\DUrole{n}{map}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Initializes the map of the environment.

\end{fulllineitems}

\index{\_PlotSample() (SimulatedRobot.SimulatedRobot method)@\spxentry{\_PlotSample()}\spxextra{SimulatedRobot.SimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:SimulatedRobot.SimulatedRobot._PlotSample}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_PlotSample}}}{\sphinxparam{\DUrole{n}{x}}\sphinxparamcomma \sphinxparam{\DUrole{n}{P}}\sphinxparamcomma \sphinxparam{\DUrole{n}{n}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Plots n samples of a multivariate gaussian distribution. This function is used only for testing, to plot the
uncertainty through samples.
:param x: mean pose of the distribution
:param P: covariance of the distribution
:param n: number of samples to plot

\end{fulllineitems}


\end{fulllineitems}



\subsection{3 DOF Diferential Drive Robot Simulation}
\label{\detokenize{robot_simulation:dof-diferential-drive-robot-simulation}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.75]{{DifferentialDriveSimulatedRobot}.png}
\caption{DifferentialDriveSimulatedRobot Class Diagram.}\label{\detokenize{robot_simulation:id2}}\end{figure}
\index{DifferentialDriveSimulatedRobot (class in DifferentialDriveSimulatedRobot)@\spxentry{DifferentialDriveSimulatedRobot}\spxextra{class in DifferentialDriveSimulatedRobot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:DifferentialDriveSimulatedRobot.DifferentialDriveSimulatedRobot}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{DifferentialDriveSimulatedRobot.}}\sphinxbfcode{\sphinxupquote{DifferentialDriveSimulatedRobot}}}{\sphinxparam{\DUrole{n}{xs0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{map}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{robot_simulation:SimulatedRobot.SimulatedRobot}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SimulatedRobot}}}}}

\sphinxAtStartPar
This class implements a simulated differential drive robot. It inherits from the \sphinxcode{\sphinxupquote{SimulatedRobot}} class and
overrides some of its methods to define the differential drive robot motion model.
\index{\_\_init\_\_() (DifferentialDriveSimulatedRobot.DifferentialDriveSimulatedRobot method)@\spxentry{\_\_init\_\_()}\spxextra{DifferentialDriveSimulatedRobot.DifferentialDriveSimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:DifferentialDriveSimulatedRobot.DifferentialDriveSimulatedRobot.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{n}{xs0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{map}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xs0}} \textendash{} initial simulated robot state \(\mathbf{x_{s_0}}=[^Nx{_{s_0}}~^Ny{_{s_0}}~^N\psi{_{s_0}}~]^T\) used to initialize the  motion model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{map}} \textendash{} feature map of the environment \(M=[^Nx_{F_1},...,^Nx_{F_{nf}}]\)

\end{itemize}

\end{description}\end{quote}

\sphinxAtStartPar
Initializes the simulated differential drive robot. Overrides some of the object attributes of the parent class \sphinxcode{\sphinxupquote{SimulatedRobot}} to define the differential drive robot motion model:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Qsk} : Object attribute containing Covariance of the simulation motion model noise.

\end{itemize}
\begin{equation}\label{equation:robot_simulation:eq:Qsk}
\begin{split}Q_k=\begin{bmatrix}\sigma_{\dot u}^2 & 0 & 0\\
0 & \sigma_{\dot v}^2 & 0 \\
0 & 0 & \sigma_{\dot r}^2 \\
\end{bmatrix}\end{split}
\end{equation}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{usk} : Object attribute containing the simulated input to the motion model containing the forward velocity \(u_k\) and the angular velocity \(r_k\)

\end{itemize}
\begin{equation}\label{equation:robot_simulation:eq:usk}
\begin{split}\bf{u_k}=\begin{bmatrix}u_k & r_k\end{bmatrix}^T\end{split}
\end{equation}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{xsk} : Object attribute containing the current simulated robot state

\end{itemize}
\begin{equation}\label{equation:robot_simulation:eq:xsk}
\begin{split}x_k=\begin{bmatrix}{^N}x_k & {^N}y_k & {^N}\theta_k & {^B}u_k & {^B}v_k & {^B}r_k\end{bmatrix}^T\end{split}
\end{equation}
\sphinxAtStartPar
where \({^N}x_k\), \({^N}y_k\) and \({^N}\theta_k\) are the robot position and orientation in the world N\sphinxhyphen{}Frame, and \({^B}u_k\), \({^B}v_k\) and \({^B}r_k\) are the robot linear and angular velocities in the robot B\sphinxhyphen{}Frame.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{zsk} : Object attribute containing \(z_{s_k}=[n_L~n_R]^T\) observation vector containing number of pulses read from the left and right wheel encoders.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Rsk} : Object attribute containing \(R_{s_k}=diag(\sigma_L^2,\sigma_R^2)\) covariance matrix of the noise of the read pulses\textasciigrave{}.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{wheelBase} : Object attribute containing the distance between the wheels of the robot (\(w=0.5\) m)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{wheelRadius} : Object attribute containing the radius of the wheels of the robot (\(R=0.1\) m)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{pulses\_x\_wheelTurn} : Object attribute containing the number of pulses per wheel turn (\(pulseXwheelTurn=1024\) pulses)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Polar2D\_max\_range} : Object attribute containing the maximum Polar2D range (\(Polar2D_max_range=50\) m) at which the robot can detect features.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Polar2D\_feature\_reading\_frequency} : Object attribute containing the frequency of Polar2D feature readings (50 tics \sphinxhyphen{}sample times\sphinxhyphen{})

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Rfp} : Object attribute containing the covariance of the simulated Polar2D feature noise (\(R_{fp}=diag(\sigma_{\rho}^2,\sigma_{\phi}^2)\))

\end{itemize}

\sphinxAtStartPar
Check the parent class \sphinxcode{\sphinxupquote{prpy.SimulatedRobot}} to know the rest of the object attributes.

\end{fulllineitems}

\index{fs() (DifferentialDriveSimulatedRobot.DifferentialDriveSimulatedRobot method)@\spxentry{fs()}\spxextra{DifferentialDriveSimulatedRobot.DifferentialDriveSimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:DifferentialDriveSimulatedRobot.DifferentialDriveSimulatedRobot.fs}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fs}}}{\sphinxparam{\DUrole{n}{xsk\_1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{usk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Motion model used to simulate the robot motion. Computes the current robot state \(x_k\) given the previous robot state \(x_{k-1}\) and the input \(u_k\):
\begin{equation}\label{equation:robot_simulation:eq:fs}
\begin{split}\eta_{s_{k-1}}&=\begin{bmatrix}x_{s_{k-1}} & y_{s_{k-1}} & \theta_{s_{k-1}}\end{bmatrix}^T\\
\nu_{s_{k-1}}&=\begin{bmatrix} u_{s_{k-1}} &  v_{s_{k-1}} & r_{s_{k-1}}\end{bmatrix}^T\\
x_{s_{k-1}}&=\begin{bmatrix}\eta_{s_{k-1}}^T & \nu_{s_{k-1}}^T\end{bmatrix}^T\\
u_{s_k}&=\nu_{d}=\begin{bmatrix} u_d& r_d\end{bmatrix}^T\\
w_{s_k}&=\dot \nu_{s_k}\\
x_{s_k}&=f_s(x_{s_{k-1}},u_{s_k},w_{s_k}) \\
&=\begin{bmatrix}
\eta_{s_{k-1}} \oplus (\nu_{s_{k-1}}\Delta t + \frac{1}{2} w_{s_k} \Delta t^2) \\
\nu_{s_{k-1}}+K(\nu_{d}-\nu_{s_{k-1}}) + w_{s_k} \Delta t
\end{bmatrix} \quad;\quad K=diag(k_1,k_2,k_3) \quad k_i>0\\\end{split}
\end{equation}
\sphinxAtStartPar
Where \(\eta_{s_{k-1}}\) is the previous 3 DOF robot pose (x,y,yaw) and \(\nu_{s_{k-1}}\) is the previous robot velocity (velocity in the direction of x and y B\sphinxhyphen{}Frame axis of the robot and the angular velocity).
\(u_{s_k}\) is the input to the motion model contaning the desired robot velocity in the x direction (\(u_d\)) and the desired angular velocity around the z axis (\(r_d\)).
\(w_{s_k}\) is the motion model noise representing an acceleration perturbation in the robot axis. The \(w_{s_k}\) acceleration is the responsible for the slight velocity variation in the simulated robot motion.
\(K\) is a diagonal matrix containing the gains used to drive the simulated velocity towards the desired input velocity.

\sphinxAtStartPar
Finally, the class updates the object attributes \(xsk\), \(xsk\_1\) and  \(usk\) to made them available for plotting purposes.

\sphinxAtStartPar
\sphinxstylestrong{To be completed by the student}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xsk\_1}} \textendash{} previous robot state \(x_{s_{k-1}}=\begin{bmatrix}\eta_{s_{k-1}}^T & \nu_{s_{k-1}}^T\end{bmatrix}^T\)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{usk}} \textendash{} model input \(u_{s_k}=\nu_{d}=\begin{bmatrix} u_d& r_d\end{bmatrix}^T\)

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
current robot state \(x_{s_k}\)

\end{description}\end{quote}

\end{fulllineitems}

\index{ReadEncoders() (DifferentialDriveSimulatedRobot.DifferentialDriveSimulatedRobot method)@\spxentry{ReadEncoders()}\spxextra{DifferentialDriveSimulatedRobot.DifferentialDriveSimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:DifferentialDriveSimulatedRobot.DifferentialDriveSimulatedRobot.ReadEncoders}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ReadEncoders}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Simulates the robot measurements of the left and right wheel encoders.

\sphinxAtStartPar
\sphinxstylestrong{To be completed by the student}.
\begin{quote}\begin{description}
\sphinxlineitem{Return zsk,Rsk}
\sphinxAtStartPar
\(zk=[\Delta n_L~ \Delta n_R]^T\) observation vector containing number of pulses read from the left and right wheel encoders during the last differential motion. \(R_{s_k}=diag(\sigma_L^2,\sigma_R^2)\) covariance matrix of the read pulses.

\end{description}\end{quote}

\end{fulllineitems}

\index{ReadCompass() (DifferentialDriveSimulatedRobot.DifferentialDriveSimulatedRobot method)@\spxentry{ReadCompass()}\spxextra{DifferentialDriveSimulatedRobot.DifferentialDriveSimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:DifferentialDriveSimulatedRobot.DifferentialDriveSimulatedRobot.ReadCompass}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ReadCompass}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Simulates the compass reading of the robot.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
yaw and the covariance of its noise \sphinxstyleemphasis{R\_yaw}

\end{description}\end{quote}

\end{fulllineitems}

\index{ReadCartesian2DFeature() (DifferentialDriveSimulatedRobot.DifferentialDriveSimulatedRobot method)@\spxentry{ReadCartesian2DFeature()}\spxextra{DifferentialDriveSimulatedRobot.DifferentialDriveSimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:DifferentialDriveSimulatedRobot.DifferentialDriveSimulatedRobot.ReadCartesian2DFeature}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ReadCartesian2DFeature}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Simulates the reading of 2D cartesian features. The features are placed in the map in cartesian coordinates.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{description}
\sphinxlineitem{zsk: {[}{[}x1 y1{]},,{[}xn yn{]}{]}}
\sphinxAtStartPar
Cartesian position of the feature observations.

\sphinxlineitem{Rsk: block\_diag(R\_1,,R\_n), where R\_i={[}{[}r\_xx r\_xy{]},{[}r\_xy r\_yy{]}{]} is the}
\sphinxAtStartPar
2x2 i\sphinxhyphen{}th feature observation covariance.
Covariance of the Cartesian feature observations. Note the features are uncorrelated among them.

\end{description}


\end{description}\end{quote}

\end{fulllineitems}

\index{ReadPolar2DFeature() (DifferentialDriveSimulatedRobot.DifferentialDriveSimulatedRobot method)@\spxentry{ReadPolar2DFeature()}\spxextra{DifferentialDriveSimulatedRobot.DifferentialDriveSimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:DifferentialDriveSimulatedRobot.DifferentialDriveSimulatedRobot.ReadPolar2DFeature}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ReadPolar2DFeature}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Simulates the reading of 2D Polar features. The features are placed in the map in cartesian coordinates.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{description}
\sphinxlineitem{zsk: {[}{[}x1 y1 z1{]},,{[}xn yn zn{]}{]}}
\sphinxAtStartPar
Cartesian position of the feature observations.

\sphinxlineitem{Rsk: block\_diag(R\_1,,R\_n), where R\_i={[}{[}r\_xx r\_xy r\_xz{]},{[}r\_xy r\_yy r\_yz{]},{[}r\_xz r\_yz r\_yy{]}{]} is the}
\sphinxAtStartPar
2x2 i\sphinxhyphen{}th feature observation covariance.
Covariance of the Polar feature observations. Note the features are uncorrelated among them.

\end{description}


\end{description}\end{quote}

\end{fulllineitems}

\index{ReadRanges() (DifferentialDriveSimulatedRobot.DifferentialDriveSimulatedRobot method)@\spxentry{ReadRanges()}\spxextra{DifferentialDriveSimulatedRobot.DifferentialDriveSimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:DifferentialDriveSimulatedRobot.DifferentialDriveSimulatedRobot.ReadRanges}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ReadRanges}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Simulates the reading of distance towards 2D Cartessian features. Returns a vector of distances towards the features within the maximum range \sphinxcode{\sphinxupquote{Distance\_max\_range}}.
The functions works at a frequency of \sphinxcode{\sphinxupquote{Distance\_feature\_reading\_frequency}}.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
vector of distances towards the features.

\end{description}\end{quote}

\end{fulllineitems}

\index{PlotRobot() (DifferentialDriveSimulatedRobot.DifferentialDriveSimulatedRobot method)@\spxentry{PlotRobot()}\spxextra{DifferentialDriveSimulatedRobot.DifferentialDriveSimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:DifferentialDriveSimulatedRobot.DifferentialDriveSimulatedRobot.PlotRobot}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{PlotRobot}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Updates the plot of the robot at the current pose

\end{fulllineitems}


\end{fulllineitems}



\subsection{4 DOF AUV Robot Simulation}
\label{\detokenize{robot_simulation:dof-auv-robot-simulation}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.75]{{AUV4DOFSimulatedRobot}.png}
\caption{AUV4DOFSimulatedRobot Class Diagram.}\label{\detokenize{robot_simulation:id3}}\end{figure}
\index{AUV4DOFSimulatedRobot (class in AUV4DOFSimulatedRobot)@\spxentry{AUV4DOFSimulatedRobot}\spxextra{class in AUV4DOFSimulatedRobot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{AUV4DOFSimulatedRobot.}}\sphinxbfcode{\sphinxupquote{AUV4DOFSimulatedRobot}}}{\sphinxparam{\DUrole{n}{xs0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{map}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{robot_simulation:SimulatedRobot.SimulatedRobot}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SimulatedRobot}}}}}

\sphinxAtStartPar
This class simulates an AUV equipped with the following sensors: Gyro, Compass, DVL, Depth, direct USBL and  inverted USBL.
\index{dt (AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot attribute)@\spxentry{dt}\spxextra{AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot.dt}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{dt}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }0.1}}}
\pysigstopsignatures
\sphinxAtStartPar
class attribute containing sample time of the simulation

\end{fulllineitems}

\index{\_\_init\_\_() (AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method)@\spxentry{\_\_init\_\_()}\spxextra{AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{n}{xs0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{map}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Constructor.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xs0}} \textendash{} initial simulated robot pose \(x_{s_k}=[x_{s_k},y_{s_k},z_{s_k},\psi_{s_k}]\)  in the N\sphinxhyphen{}Frame

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{map}} \textendash{} map of the environment

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{PlotRobot() (AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method)@\spxentry{PlotRobot()}\spxextra{AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot.PlotRobot}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{PlotRobot}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Updates the plot of the robot at the current pose

\end{fulllineitems}

\index{fs() (AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method)@\spxentry{fs()}\spxextra{AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot.fs}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fs}}}{\sphinxparam{\DUrole{n}{xsk\_1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{usk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Motion model used to simulate the robot motion. Computes the current robot state \(x_k\) given the previous robot state \(x_{k-1}\) and the input \(u_k\):
\begin{equation}\label{equation:robot_simulation:eq:AUV4DOFSimulatedRobot-fs}
\begin{split}\eta_{s_{k-1}}&=\begin{bmatrix}x_{s_{k-1}} & y_{s_{k-1}} & z_{s_{k-1}} & \psi_{s_{k-1}}\end{bmatrix}^T\\
\nu_{s_{k-1}}&=\begin{bmatrix} u_{s_{k-1}} &  v_{s_{k-1}} & w_{s_{k-1}} & r_{s_{k-1}}\end{bmatrix}^T\\
x_{s_{k-1}}&=\begin{bmatrix}\eta_{s_{k-1}}^T & \nu_{s_{k-1}}^T\end{bmatrix}^T\\
u_{s_k}&=\nu_{d}=\begin{bmatrix} u_d& v_d& w_d& r_d\end{bmatrix}^T\\
w_{s_k}&=\dot \nu_{s_k}\\
x_{s_k}&=f_s(x_{s_{k-1}},u_{s_k},w_{s_k}) \\
&=\begin{bmatrix}
\eta_{s_{k-1}} \oplus (\nu_{s_{k-1}}\Delta t + \frac{1}{2} w_{s_k}) \\
\nu_{s_{k-1}}+K(\nu_{d}-\nu_{s_{k-1}}) + w_{s_k} \Delta t
\end{bmatrix} \quad;\quad K=diag(k_1,k_2,k_3,k_4) \quad k_i>0\\\end{split}
\end{equation}
\sphinxAtStartPar
Where \(\eta_{s_{k-1}}\) is the previous 3 DOF robot pose (x,y,yaw) and \(\nu_{s_{k-1}}\) is the previous robot velocity (velocity in the direction of x and y B\sphinxhyphen{}Frame axis of the robot and the angular velocity).
\(u_{s_k}\) is the input to the motion model contaning the desired robot velocity in the x direction (\(u_d\)) and the desired angular velocity around the z axis (\(r_d\)).
\(w_{s_k}\) is the motion model noise representing an acceleration perturbation in the robot axis. The \(w_{s_k}\) acceleration is the responsible for the slight velocity variation in the simulated robot motion.
\(K\) is a diagonal matrix containing the gains used to drive the simulated velocity towards the desired input velocity.

\sphinxAtStartPar
Finally, the class updates the object attributes \(xsk\), \(xsk\_1\) and  \(usk\) to made them available for plotting purposes.

\sphinxAtStartPar
\sphinxstylestrong{To be completed by the student}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xsk\_1}} \textendash{} previous robot state \(x_{s_{k-1}}=\begin{bmatrix}\eta_{s_{k-1}}^T & \nu_{s_{k-1}}^T\end{bmatrix}^T\)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{usk}} \textendash{} model input \(u_{s_k}=\nu_{d}=\begin{bmatrix} u_d& r_d\end{bmatrix}^T\)

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
current robot state \(x_{s_k}\)

\end{description}\end{quote}

\end{fulllineitems}

\index{SetMap() (AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method)@\spxentry{SetMap()}\spxextra{AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot.SetMap}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{SetMap}}}{\sphinxparam{\DUrole{n}{map}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Initializes the map of the environment.

\end{fulllineitems}

\index{ReadGyro() (AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method)@\spxentry{ReadGyro()}\spxextra{AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot.ReadGyro}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ReadGyro}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Simulates the gyro reading of the robot.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
angular velocity {[}r{]} and the covariance of the noise {[}R\_r{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{ReadCompass() (AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method)@\spxentry{ReadCompass()}\spxextra{AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot.ReadCompass}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ReadCompass}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Simulates the compass reading of the robot.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
yaw and the covariance of its noise \sphinxstyleemphasis{R\_yaw}

\end{description}\end{quote}

\end{fulllineitems}

\index{ReadDVL() (AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method)@\spxentry{ReadDVL()}\spxextra{AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot.ReadDVL}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ReadDVL}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Simulates the DVL reading of the robot.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
linear velocity {[}u v w{]} and the covariance of the noise {[}R\_lin\_vel{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{ReadDepth() (AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method)@\spxentry{ReadDepth()}\spxextra{AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot.ReadDepth}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ReadDepth}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Simulates the depth reading of the robot.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
depth and the covariance of the noise {[}R\_depth{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{ReadUSBL() (AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method)@\spxentry{ReadUSBL()}\spxextra{AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot.ReadUSBL}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ReadUSBL}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Simulates the USBL reading of the robot. Assumes that the USBL transceiver is placed at the origin of the
N\_Frame and the transceiver is placed at the origin of the robots B\sphinxhyphen{}Frame.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
zsk: cartesian position {[}x y z{]}
Rsk: Covariance of the noise {[}R\_usbl\_cartesian{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{ReadSpherical3DFeature() (AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method)@\spxentry{ReadSpherical3DFeature()}\spxextra{AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot.ReadSpherical3DFeature}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ReadSpherical3DFeature}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Simulates the inverted USBL sensor. In this case the transceiver is mounted at the origin of the robots B\sphinxhyphen{}Frame
and n transponders are layed out on the seafloor. The Cartesian position of the transponders is stored in the map
in Cartesian coordinates.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
zsk={[}{[}r\_0 theta\_0 varphi\_0{]},,{[}r\_i theta\_i varphi\_i{]},{[}r\_n theta\_n varphi\_n{]}{]},
Rsk=block\_diag(R\_0,,R\_i,,R\_n)

\end{description}\end{quote}

\sphinxAtStartPar
where {[}r\_i theta\_i phi\_i{]} is the spherical position of the i transponder, being, r\_i the distance, theta\_i the
elevation angle and varphi\_i the azimuth angle. The covariance is a block diagonal matrix (since the transponder
positions are uncorrelated) where each block is a 3x3 matrix corresponding to the covariance of the noise of each
transponder within the range of the sensor.

\end{fulllineitems}

\index{ReadCartesian2DFeature() (AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method)@\spxentry{ReadCartesian2DFeature()}\spxextra{AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot.ReadCartesian2DFeature}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ReadCartesian2DFeature}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Simulates the reading of 2D cartesian features. The features are placed in the map in cartesian coordinates.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{description}
\sphinxlineitem{zsk: {[}{[}x1 y1{]},,{[}xn yn{]}{]}}
\sphinxAtStartPar
Cartesian position of the feature observations.

\sphinxlineitem{Rsk: block\_diag(R\_1,,R\_n), where R\_i={[}{[}r\_xx r\_xy{]},{[}r\_xy r\_yy{]}{]} is the}
\sphinxAtStartPar
2x2 i\sphinxhyphen{}th feature observation covariance.
Covariance of the Cartesian feature observations. Note the features are uncorrelated among them.

\end{description}


\end{description}\end{quote}

\end{fulllineitems}

\index{ReadPolar2DFeature() (AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method)@\spxentry{ReadPolar2DFeature()}\spxextra{AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot.ReadPolar2DFeature}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ReadPolar2DFeature}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Simulates the reading of 2D Polar features. The features are placed in the map in cartesian coordinates.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{description}
\sphinxlineitem{zsk: {[}{[}x1 y1 z1{]},,{[}xn yn zn{]}{]}}
\sphinxAtStartPar
Cartesian position of the feature observations.

\sphinxlineitem{Rsk: block\_diag(R\_1,,R\_n), where R\_i={[}{[}r\_xx r\_xy r\_xz{]},{[}r\_xy r\_yy r\_yz{]},{[}r\_xz r\_yz r\_yy{]}{]} is the}
\sphinxAtStartPar
2x2 i\sphinxhyphen{}th feature observation covariance.
Covariance of the Polar feature observations. Note the features are uncorrelated among them.

\end{description}


\end{description}\end{quote}

\end{fulllineitems}

\index{ReadRanges() (AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method)@\spxentry{ReadRanges()}\spxextra{AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot.ReadRanges}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ReadRanges}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Simulates the reading of distance towards 2D Cartessian features. Returns a vector of distances towards the features within the maximum range \sphinxcode{\sphinxupquote{Distance\_max\_range}}.
The functions works at a frequency of \sphinxcode{\sphinxupquote{Distance\_feature\_reading\_frequency}}.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
vector of distances towards the features.

\end{description}\end{quote}

\end{fulllineitems}

\index{ReadCartesian3DFeature() (AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method)@\spxentry{ReadCartesian3DFeature()}\spxextra{AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot.ReadCartesian3DFeature}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ReadCartesian3DFeature}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Simulates the reading of 3D cartesian features. The features are placed in the map in cartesian coordinates.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{description}
\sphinxlineitem{zsk: {[}{[}x1 y1 z1{]},,{[}xn yn zn{]}{]}}
\sphinxAtStartPar
Cartesian position of the feature observations.

\sphinxlineitem{Rsk: block\_diag(R\_1,,R\_n), where R\_i={[}{[}r\_xx r\_xy r\_xz{]},{[}r\_xy r\_yy r\_yz{]},{[}r\_xz r\_yz r\_yy{]}{]} is the}
\sphinxAtStartPar
3x3 i\sphinxhyphen{}th feature observation covariance.
Covariance of the Cartesian feature observations. Note the features are uncorrelated among them.

\end{description}


\end{description}\end{quote}

\end{fulllineitems}

\index{\_PlotSample() (AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method)@\spxentry{\_PlotSample()}\spxextra{AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robot_simulation:AUV4DOFSimulatedRobot.AUV4DOFSimulatedRobot._PlotSample}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_PlotSample}}}{\sphinxparam{\DUrole{n}{x}}\sphinxparamcomma \sphinxparam{\DUrole{n}{P}}\sphinxparamcomma \sphinxparam{\DUrole{n}{n}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Plots n samples of a multivariate gaussian distribution. This function is used only for testing, to plot the
uncertainty through samples.
:param x: mean pose of the distribution
:param P: covariance of the distribution
:param n: number of samples to plot

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\section{Filters}
\label{\detokenize{Filters:filters}}\label{\detokenize{Filters::doc}}

\subsection{Histogram Filter}
\label{\detokenize{Filters:histogram-filter}}
\sphinxstepscope


\subsubsection{Histogram Filter}
\label{\detokenize{HF:histogram-filter}}\label{\detokenize{HF::doc}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{HF}.png}
\end{figure}
\index{HF (class in HF)@\spxentry{HF}\spxextra{class in HF}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HF:HF.HF}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{HF.}}\sphinxbfcode{\sphinxupquote{HF}}}{\sphinxparam{\DUrole{n}{p0}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Histogram Filter base class. Implements the histogram filter algorithm using a discrete Bayes Filter.
\index{\_\_init\_\_() (HF.HF method)@\spxentry{\_\_init\_\_()}\spxextra{HF.HF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HF:HF.HF.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{n}{p0}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The histogram filter is initialized with the initial probability histogram \sphinxstyleemphasis{p0}. It creates the following attributes:
\begin{itemize}
\item {} 
\sphinxAtStartPar
self.p0: the initial belief histogram

\item {} 
\sphinxAtStartPar
self.pk\_1: the previous belief histogram, initially initialized from \sphinxstyleemphasis{p0}

\item {} 
\sphinxAtStartPar
self.pk\_hat: the prior belief histogram, after applying the Total Probability theorem

\item {} 
\sphinxAtStartPar
self.pk: the posterior belief histogram, after applying the Bayes Rule

\end{itemize}

\sphinxAtStartPar
that will be updated during the execution of the filter. This method also initializes the state transition
probability matrix \sphinxstyleemphasis{self.Pk}. If the file \sphinxstyleemphasis{StateTransitionProbability.npy} exists, the matrix will be loaded from it.
Otherwise, it is computed by the derived class through the pure virtual method \sphinxstyleemphasis{StateTransitionProbability()} and stored
in the file for posterior uses. This is done to avoid recomputing the matrix every since this is a time\sphinxhyphen{}consuming operation.
The state transition probability matrix is used in the {\hyperref[\detokenize{HF:HF.HF.Prediction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Prediction()}}}}} step and the measurement probability
matrix is used in the {\hyperref[\detokenize{HF:HF.HF.Update}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Update()}}}}} one.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{p0}} \textendash{} initial probability histogram

\end{description}\end{quote}

\end{fulllineitems}

\index{ToCell() (HF.HF method)@\spxentry{ToCell()}\spxextra{HF.HF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HF:HF.HF.ToCell}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ToCell}}}{\sphinxparam{\DUrole{n}{m}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Converts a metric value to a cell displacement.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{m}} \textendash{} value in meters

\sphinxlineitem{Returns}
\sphinxAtStartPar
value in cells

\end{description}\end{quote}

\end{fulllineitems}

\index{StateTransitionProbability() (HF.HF method)@\spxentry{StateTransitionProbability()}\spxextra{HF.HF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HF:HF.HF.StateTransitionProbability}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{StateTransitionProbability}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Returns the state transition probability matrix.
This is a pure virtual method that must be implemented by the derived class.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstyleemphasis{Pk} state transition probability matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{StateTransitionProbability\_4\_uk() (HF.HF method)@\spxentry{StateTransitionProbability\_4\_uk()}\spxextra{HF.HF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HF:HF.HF.StateTransitionProbability_4_uk}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{StateTransitionProbability\_4\_uk}}}{\sphinxparam{\DUrole{n}{uk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Returns the state transition probability matrix for the given control input \sphinxstyleemphasis{uk}.
This is a pure virtual method that must be implemented by the derived class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{uk}} \textendash{} control input. In localization, this is commonly the robot displacement. For example, in the case of a differential drive robot, this is the robot displacement in the robot frame commonly computed through the odometry.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstyleemphasis{Puk} state transition probability matrix for a given uk

\end{description}\end{quote}

\end{fulllineitems}

\index{MeasurementProbability() (HF.HF method)@\spxentry{MeasurementProbability()}\spxextra{HF.HF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HF:HF.HF.MeasurementProbability}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{MeasurementProbability}}}{\sphinxparam{\DUrole{n}{zk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Returns the measurement probability matrix for the given measurement \sphinxstyleemphasis{zk}.
This is a pure virtual method that must be implemented by the derived class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{zk}} \textendash{} measurement.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstyleemphasis{pzk} measurement probability histogram

\end{description}\end{quote}

\end{fulllineitems}

\index{uk2cell() (HF.HF method)@\spxentry{uk2cell()}\spxextra{HF.HF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HF:HF.HF.uk2cell}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{uk2cell}}}{\sphinxparam{\DUrole{n}{uk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Converts the control input \sphinxstyleemphasis{uk} to a cell displacement.
:param uk:
:return:

\end{fulllineitems}

\index{Prediction() (HF.HF method)@\spxentry{Prediction()}\spxextra{HF.HF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HF:HF.HF.Prediction}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Prediction}}}{\sphinxparam{\DUrole{n}{pk\_1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{uk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Computes the prediction step of the histogram filter. Given the previous probability histogram \sphinxstyleemphasis{pk\_1} and the
control input \sphinxstyleemphasis{uk}, it computes the predicted probability histogram \sphinxstyleemphasis{pk\_hat} after the robot displacement \sphinxstyleemphasis{uk}
according to the motion model described by the state transition probability.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pk\_1}} \textendash{} previous probability histogram

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{uk}} \textendash{} control input

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstyleemphasis{pk\_hat} predicted probability histogram

\end{description}\end{quote}

\end{fulllineitems}

\index{Update() (HF.HF method)@\spxentry{Update()}\spxextra{HF.HF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HF:HF.HF.Update}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Update}}}{\sphinxparam{\DUrole{n}{pk\_hat}}\sphinxparamcomma \sphinxparam{\DUrole{n}{zk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Computes the update step of the histogram filter. Given the predicted probability histogram \sphinxstyleemphasis{pk\_hat} and the measurement \sphinxstyleemphasis{zk}, it computes first the measurement probability histogram \sphinxstyleemphasis{pzk} and then uses the Bayes Rule to compute the updated probability histogram \sphinxstyleemphasis{pk}.
:param pk\_hat: predicted probability histogram
:param zk: measurement
:return: pk: updated probability histogram

\end{fulllineitems}


\end{fulllineitems}

\index{Histogram2D (class in Histogram)@\spxentry{Histogram2D}\spxextra{class in Histogram}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HF:Histogram.Histogram2D}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{Histogram.}}\sphinxbfcode{\sphinxupquote{Histogram2D}}}{\sphinxparam{\DUrole{n}{num\_bins\_x}}\sphinxparamcomma \sphinxparam{\DUrole{n}{num\_bins\_y}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x\_range}}\sphinxparamcomma \sphinxparam{\DUrole{n}{y\_range}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Class for creating and manipulating a 2D histogram.
\index{\_\_init\_\_() (Histogram.Histogram2D method)@\spxentry{\_\_init\_\_()}\spxextra{Histogram.Histogram2D method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HF:Histogram.Histogram2D.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{n}{num\_bins\_x}}\sphinxparamcomma \sphinxparam{\DUrole{n}{num\_bins\_y}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x\_range}}\sphinxparamcomma \sphinxparam{\DUrole{n}{y\_range}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Initialize a new Histogram2D instance.
\begin{quote}\begin{description}
\sphinxlineitem{Param}
\sphinxAtStartPar
num\_bins\_x (int): Number of bins in the X\sphinxhyphen{}direction.
num\_bins\_y (int): Number of bins in the Y\sphinxhyphen{}direction.
x\_range (numpy.ndarray): Range of values for the X\sphinxhyphen{}axis.
y\_range (numpy.ndarray): Range of values for the Y\sphinxhyphen{}axis.

\end{description}\end{quote}

\end{fulllineitems}

\index{histogram\_2d (Histogram.Histogram2D property)@\spxentry{histogram\_2d}\spxextra{Histogram.Histogram2D property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HF:Histogram.Histogram2D.histogram_2d}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{histogram\_2d}}}
\pysigstopsignatures
\sphinxAtStartPar
Get the 2D histogram data as a NumPy array.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
numpy.ndarray: The 2D histogram data.

\end{description}\end{quote}

\end{fulllineitems}

\index{histogram\_1d (Histogram.Histogram2D property)@\spxentry{histogram\_1d}\spxextra{Histogram.Histogram2D property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HF:Histogram.Histogram2D.histogram_1d}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{histogram\_1d}}}
\pysigstopsignatures
\sphinxAtStartPar
Get the histogram data as a 1D NumPy array.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
numpy.ndarray: The 1D histogram data.

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_histogram() (Histogram.Histogram2D method)@\spxentry{plot\_histogram()}\spxextra{Histogram.Histogram2D method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HF:Histogram.Histogram2D.plot_histogram}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot\_histogram}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Plot the 2D histogram using Matplotlib.

\end{fulllineitems}

\index{element (Histogram.Histogram2D property)@\spxentry{element}\spxextra{Histogram.Histogram2D property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HF:Histogram.Histogram2D.element}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{element}}}
\pysigstopsignatures
\sphinxAtStartPar
Property to access individual elements of the histogram using range values.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
ElementAccessor: An instance of ElementAccessor for getting and setting individual elements by range.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Particle Filter}
\label{\detokenize{Filters:particle-filter}}
\sphinxstepscope


\subsubsection{Particle Filter}
\label{\detokenize{PF:particle-filter}}\label{\detokenize{PF::doc}}
\sphinxAtStartPar
To be completed


\subsection{Kalman Filter}
\label{\detokenize{Filters:kalman-filter}}
\sphinxstepscope


\subsubsection{Kalman Filter}
\label{\detokenize{KF:kalman-filter}}\label{\detokenize{KF::doc}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{KF}.png}
\end{figure}
\index{KF (class in KF)@\spxentry{KF}\spxextra{class in KF}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{KF:KF.KF}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{KF.}}\sphinxbfcode{\sphinxupquote{KF}}}{\sphinxparam{\DUrole{n}{Ak}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Bk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Hk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Vk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{P0}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{GaussianFilter}}

\sphinxAtStartPar
Kalman Filter class. Implements the \sphinxcode{\sphinxupquote{GaussianFilter}} interface for the particular case of the Kalman Filter.
\index{\_\_init\_\_() (KF.KF method)@\spxentry{\_\_init\_\_()}\spxextra{KF.KF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{KF:KF.KF.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{n}{Ak}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Bk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Hk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Vk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{P0}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Constructor of the KF class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Ak}} \textendash{} Transition matrix of the motion model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Bk}} \textendash{} Input matrix of the motion model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Hk}} \textendash{} Observation matrix of the observation model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Vk}} \textendash{} Noise projection matrix of the motion model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x0}} \textendash{} initial mean of the state vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{P0}} \textendash{} initial covariance matrix

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{args}} \textendash{} arguments to be passed to the parent class

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{Prediction() (KF.KF method)@\spxentry{Prediction()}\spxextra{KF.KF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{KF:KF.KF.Prediction}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Prediction}}}{\sphinxparam{\DUrole{n}{uk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Qk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{xk\_1}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Pk\_1}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Prediction step of the Kalman Filter.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{uk}} \textendash{} input vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Qk}} \textendash{} covariance matrix of the motion model noise

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_1}} \textendash{} previous mean state vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Pk\_1}} \textendash{} previous covariance matrix

\end{itemize}

\sphinxlineitem{Return xk\_bar, Pk\_bar}
\sphinxAtStartPar
current mean state vector and covariance matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{Update() (KF.KF method)@\spxentry{Update()}\spxextra{KF.KF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{KF:KF.KF.Update}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Update}}}{\sphinxparam{\DUrole{n}{zk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Rk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{xk\_bar}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Pk\_bar}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Update step of the Kalman Filter.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{zk}} \textendash{} observation vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Rk}} \textendash{} covariance of the observation model noise

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_bar}} \textendash{} predicted mean state vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Pk\_bar}} \textendash{} predicted covariance matrix

\end{itemize}

\sphinxlineitem{Return xk.Pk}
\sphinxAtStartPar
current mean state vector and covariance matrix

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Extended Kalman Filter}
\label{\detokenize{Filters:extended-kalman-filter}}
\sphinxstepscope


\subsubsection{Extended Kalman  Filter}
\label{\detokenize{EKF:extended-kalman-filter}}\label{\detokenize{EKF::doc}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{EKF}.png}
\end{figure}
\index{EKF (class in EKF)@\spxentry{EKF}\spxextra{class in EKF}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{EKF:EKF.EKF}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{EKF.}}\sphinxbfcode{\sphinxupquote{EKF}}}{\sphinxparam{\DUrole{n}{x0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{P0}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{GaussianFilter}}

\sphinxAtStartPar
Extended Kalman Filter class. Implements the \sphinxcode{\sphinxupquote{GaussianFilter}} interface for the particular case of the Extended Kalman Filter.
\index{\_\_init\_\_() (EKF.EKF method)@\spxentry{\_\_init\_\_()}\spxextra{EKF.EKF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{EKF:EKF.EKF.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{n}{x0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{P0}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Constructor of the EKF class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x0}} \textendash{} initial mean state vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{P0}} \textendash{} initial covariance matrix

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{args}} \textendash{} arguments to be passed to the parent class

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{f() (EKF.EKF method)@\spxentry{f()}\spxextra{EKF.EKF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{EKF:EKF.EKF.f}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{f}}}{\sphinxparam{\DUrole{n}{xk\_1}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{uk}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar

Motion model of the EKF to be overwritten by the child class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_1}} \textendash{} previous mean state vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{uk}} \textendash{} input vector

\end{itemize}

\sphinxlineitem{Return xk\_bar, Pk\_bar}
\sphinxAtStartPar
predicted mean state vector and its covariance matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{Jfx() (EKF.EKF method)@\spxentry{Jfx()}\spxextra{EKF.EKF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{EKF:EKF.EKF.Jfx}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Jfx}}}{\sphinxparam{\DUrole{n}{xk\_1}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the motion model with respect to the state vector. \sphinxstyleemphasis{Method to be overwritten by the child class}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_1}} \textendash{} Linearization point. By default the linearization point is the previous state vector taken from a class attribute.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{Jfw() (EKF.EKF method)@\spxentry{Jfw()}\spxextra{EKF.EKF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{EKF:EKF.EKF.Jfw}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Jfw}}}{\sphinxparam{\DUrole{n}{xk\_1}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the motion model with respect to the noise vector. \sphinxstyleemphasis{Method to be overwritten by the child class}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_1}} \textendash{} Linearization point. By default the linearization point is the previous state vector taken from a class attribute.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{h() (EKF.EKF method)@\spxentry{h()}\spxextra{EKF.EKF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{EKF:EKF.EKF.h}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{h}}}{\sphinxparam{\DUrole{n}{xk\_bar}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Observation model of the EKF. We differentiate two types of observations:
1. \sphinxstylestrong{Measurements}: observations that are directly measured by the sensors. For example, the position of the robot, its heading, its speed, etc.
2. \sphinxstylestrong{Features}: observations of map features. For example, the position of a landmark.

\sphinxAtStartPar
This method calls the {\hyperref[\detokenize{EKF:EKF.EKF.hm}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{EKF.hm()}}}}} which implements the measurements observation equation. To implement a standard EKF, the \sphinxtitleref{EKF.hm} method should be overwritten by the child class to be used as the observation equation for measurements.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_bar}} \textendash{} mean of the predicted state vector. By default it is taken from the class attribute.

\sphinxlineitem{Returns}
\sphinxAtStartPar
expected observation vector

\end{description}\end{quote}

\end{fulllineitems}

\index{hm() (EKF.EKF method)@\spxentry{hm()}\spxextra{EKF.EKF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{EKF:EKF.EKF.hm}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{hm}}}{\sphinxparam{\DUrole{n}{xk\_bar}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Observation model related to the measurements observations of the EKF to be overwritten by the child class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_bar}} \textendash{} mean of the predicted state vector. By default it is taken from the class attribute.

\sphinxlineitem{Returns}
\sphinxAtStartPar
expected observation vector

\end{description}\end{quote}

\end{fulllineitems}

\index{Prediction() (EKF.EKF method)@\spxentry{Prediction()}\spxextra{EKF.EKF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{EKF:EKF.EKF.Prediction}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Prediction}}}{\sphinxparam{\DUrole{n}{uk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Qk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{xk\_1}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Pk\_1}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Prediction step of the EKF. It calls the motion model and its Jacobians to predict the state vector and its covariance matrix.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{uk}} \textendash{} input vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Qk}} \textendash{} covariance matrix of the noise vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_1}} \textendash{} previous mean state vector. By default it is taken from the class attribute. Otherwise it updates the class attribute.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Pk\_1}} \textendash{} covariance matrix of the previous state vector. By default it is taken from the class attribute. Otherwise it updates the class attribute.

\end{itemize}

\sphinxlineitem{Return xk\_bar, Pk\_bar}
\sphinxAtStartPar
predicted mean state vector and its covariance matrix. Also updated in the class attributes.

\end{description}\end{quote}

\end{fulllineitems}

\index{Update() (EKF.EKF method)@\spxentry{Update()}\spxextra{EKF.EKF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{EKF:EKF.EKF.Update}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Update}}}{\sphinxparam{\DUrole{n}{zk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Rk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{xk\_bar}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Pk\_bar}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Hk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Vk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Update step of the EKF. It calls the observation model and its Jacobians to update the state vector and its covariance matrix.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{zk}} \textendash{} observation vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Rk}} \textendash{} covariance matrix of the noise vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_bar}} \textendash{} predicted mean state vector. By default it is taken from the class attribute. Otherwise it updates the class attribute.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Pk\_bar}} \textendash{} covariance matrix of the predicted state vector. By default it is taken from the class attribute. Otherwise it updates the class attribute.

\end{itemize}

\sphinxlineitem{Return xk,Pk}
\sphinxAtStartPar
updated mean state vector and its covariance matrix. Also updated in the class attributes.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\section{Localization}
\label{\detokenize{Localization_index:localization}}\label{\detokenize{Localization_index::doc}}
\sphinxstepscope


\subsection{Robot Localization}
\label{\detokenize{Localization:robot-localization}}\label{\detokenize{Localization::doc}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{Localization}.png}
\end{figure}
\index{Localization (class in Localization)@\spxentry{Localization}\spxextra{class in Localization}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Localization:Localization.Localization}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{Localization.}}\sphinxbfcode{\sphinxupquote{Localization}}}{\sphinxparam{\DUrole{n}{index}}\sphinxparamcomma \sphinxparam{\DUrole{n}{kSteps}}\sphinxparamcomma \sphinxparam{\DUrole{n}{robot}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x0}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Localization base class. Implements the localization algorithm.
\index{\_\_init\_\_() (Localization.Localization method)@\spxentry{\_\_init\_\_()}\spxextra{Localization.Localization method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Localization:Localization.Localization.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{n}{index}}\sphinxparamcomma \sphinxparam{\DUrole{n}{kSteps}}\sphinxparamcomma \sphinxparam{\DUrole{n}{robot}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x0}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Constructor of the DRLocalization class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} Logging index structure (\sphinxcode{\sphinxupquote{Index}})

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kSteps}} \textendash{} Number of time steps to simulate

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{robot}} \textendash{} Simulation robot object (\sphinxcode{\sphinxupquote{Robot}})

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{args}} \textendash{} Rest of arguments to be passed to the parent constructor

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x0}} \textendash{} Initial Robot pose in the N\sphinxhyphen{}Frame

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{GetInput() (Localization.Localization method)@\spxentry{GetInput()}\spxextra{Localization.Localization method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Localization:Localization.Localization.GetInput}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetInput}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Gets the input from the robot. To be overidden by the child class.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{uk:} input variable

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{Localize() (Localization.Localization method)@\spxentry{Localize()}\spxextra{Localization.Localization method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Localization:Localization.Localization.Localize}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Localize}}}{\sphinxparam{\DUrole{n}{xk\_1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{uk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Single Localization iteration invoked from \sphinxcode{\sphinxupquote{DRLocalization.Localization()}}. Given the previous robot pose, the function reads the inout and computes the current pose.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_1}} \textendash{} previous robot pose

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{xk} current robot pose

\end{description}\end{quote}

\end{fulllineitems}

\index{LocalizationLoop() (Localization.Localization method)@\spxentry{LocalizationLoop()}\spxextra{Localization.Localization method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Localization:Localization.Localization.LocalizationLoop}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{LocalizationLoop}}}{\sphinxparam{\DUrole{n}{x0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{usk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Given an initial robot pose \(x_0\) and the input to the \sphinxcode{\sphinxupquote{SimulatedRobot}} this method calls iteratively \sphinxcode{\sphinxupquote{DRLocalization.Localize()}} for k steps, solving the robot localization problem.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x0}} \textendash{} initial robot pose

\end{description}\end{quote}

\end{fulllineitems}

\index{Log() (Localization.Localization method)@\spxentry{Log()}\spxextra{Localization.Localization method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Localization:Localization.Localization.Log}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Log}}}{\sphinxparam{\DUrole{n}{xsk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{xk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Logs the results for later plotting.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xsk}} \textendash{} ground truth robot pose from the simulation

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk}} \textendash{} estimated robot pose

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{PlotXY() (Localization.Localization method)@\spxentry{PlotXY()}\spxextra{Localization.Localization method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Localization:Localization.Localization.PlotXY}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{PlotXY}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Plots, in a new figure, the ground truth (orange) and estimated (blue) trajectory of the robot at the end of the Localization Loop.

\end{fulllineitems}

\index{PlotTrajectory() (Localization.Localization method)@\spxentry{PlotTrajectory()}\spxextra{Localization.Localization method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Localization:Localization.Localization.PlotTrajectory}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{PlotTrajectory}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Plots the estimated trajectory (blue) of the robot during the localization process.

\end{fulllineitems}


\end{fulllineitems}



\subsection{Dead Reckoning}
\label{\detokenize{Localization_index:dead-reckoning}}
\sphinxstepscope


\subsubsection{4 DOF AUV Dead REckoning using DVL and Gyro}
\label{\detokenize{DRLocalization:dof-auv-dead-reckoning-using-dvl-and-gyro}}\label{\detokenize{DRLocalization::doc}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{DR_4DOFAUV_DVLGyro}.png}
\end{figure}
\index{DR\_4DOFAUV\_DVLGyro (class in DR\_4DOFAUV\_DVLGyro)@\spxentry{DR\_4DOFAUV\_DVLGyro}\spxextra{class in DR\_4DOFAUV\_DVLGyro}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{DRLocalization:DR_4DOFAUV_DVLGyro.DR_4DOFAUV_DVLGyro}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{DR\_4DOFAUV\_DVLGyro.}}\sphinxbfcode{\sphinxupquote{DR\_4DOFAUV\_DVLGyro}}}{\sphinxparam{\DUrole{n}{index}}\sphinxparamcomma \sphinxparam{\DUrole{n}{kSteps}}\sphinxparamcomma \sphinxparam{\DUrole{n}{robot}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x0}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{Localization:Localization.Localization}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Localization}}}}}

\sphinxAtStartPar
Dead Reckoning Localization for a 4DOF AUV with DVL and Gyro sensors
\index{\_\_init\_\_() (DR\_4DOFAUV\_DVLGyro.DR\_4DOFAUV\_DVLGyro method)@\spxentry{\_\_init\_\_()}\spxextra{DR\_4DOFAUV\_DVLGyro.DR\_4DOFAUV\_DVLGyro method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{DRLocalization:DR_4DOFAUV_DVLGyro.DR_4DOFAUV_DVLGyro.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{n}{index}}\sphinxparamcomma \sphinxparam{\DUrole{n}{kSteps}}\sphinxparamcomma \sphinxparam{\DUrole{n}{robot}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x0}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Constructor of the DR\_4DOFAUV\_DVLGyro class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{args}} \textendash{} Rest of arguments to be passed to the parent constructor

\end{description}\end{quote}

\end{fulllineitems}

\index{Localize() (DR\_4DOFAUV\_DVLGyro.DR\_4DOFAUV\_DVLGyro method)@\spxentry{Localize()}\spxextra{DR\_4DOFAUV\_DVLGyro.DR\_4DOFAUV\_DVLGyro method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{DRLocalization:DR_4DOFAUV_DVLGyro.DR_4DOFAUV_DVLGyro.Localize}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Localize}}}{\sphinxparam{\DUrole{n}{xk\_1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{uk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Motion model for the 4DOF (\([x_{k}~y_{k}~z_{k}~\psi_{k}]^T\)) AUV using as input the lineal velocity read from the DVL senosr and angular velocity read from the Gyro sensor
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_1}} \textendash{} previous robot pose estimate (\([x_{k-1}~y_{k-1}~z_{k-1}~\psi_{k-1}]^T\))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{uk}} \textendash{} input vector (\([u_{k}~v_{k}~w_{k}~r_{k}]^T\))

\end{itemize}

\sphinxlineitem{Return xk}
\sphinxAtStartPar
current robot pose estimate (\([x_{k}~y_{k}~z_{k}~\psi_{k}]^T\))

\end{description}\end{quote}

\end{fulllineitems}

\index{GetInput() (DR\_4DOFAUV\_DVLGyro.DR\_4DOFAUV\_DVLGyro method)@\spxentry{GetInput()}\spxextra{DR\_4DOFAUV\_DVLGyro.DR\_4DOFAUV\_DVLGyro method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{DRLocalization:DR_4DOFAUV_DVLGyro.DR_4DOFAUV_DVLGyro.GetInput}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetInput}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Gets the input vector and the input noise covariance matrix from the robot. The input vector contains the linear read from the DVL and angular velocity read from the Gyro of the robot.
\begin{equation}\label{equation:DRLocalization:eq-uk-EKF_4DOFAUV_VelocityMM_DVLDepthYawOM}
\begin{split}u_k &= \begin{bmatrix} \nu_{DVL}^T & r_{Gyro}^T \end{bmatrix}^T= \begin{bmatrix} u_{DVL} & v_{DVL} & w_{DVL} & r_{Gyro} \end{bmatrix}^T\\
Q_k &= \begin{bmatrix} Q_{DVL} & 0 \\ 0 & \sigma_{Gyro}^2 \end{bmatrix} \quad \text{where} \quad Q_{DVL} = \begin{bmatrix} \sigma_{u_{DVL}}^2 & \sigma_{{uv}_{DVL}} & \sigma_{{uw}_{DVL}} \\ \sigma_{{vu}_{DVL}} & \sigma_{v_{DVL}}^2 &  \sigma_{{vw}_{DVL}} \\ \sigma_{{wu}_{DVL}} & \sigma_{{wv}_{DVL}} & \sigma_{w_{DVL}}^2   \end{bmatrix}\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
input vector \(u_k\) and input noise covariance matrix \(Q_k\) defined in eq. \eqref{equation:DRLocalization:eq-uk-EKF_4DOFAUV_VelocityMM_DVLDepthYawOM}.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{3 DOF Differential Drive Mobile Robot Example}
\label{\detokenize{DRLocalization:dof-differential-drive-mobile-robot-example}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{DR_3DOFDifferentialDrive}.png}
\end{figure}
\index{DR\_3DOFDifferentialDrive (class in DR\_3DOFDifferentialDrive)@\spxentry{DR\_3DOFDifferentialDrive}\spxextra{class in DR\_3DOFDifferentialDrive}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{DRLocalization:DR_3DOFDifferentialDrive.DR_3DOFDifferentialDrive}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{DR\_3DOFDifferentialDrive.}}\sphinxbfcode{\sphinxupquote{DR\_3DOFDifferentialDrive}}}{\sphinxparam{\DUrole{n}{index}}\sphinxparamcomma \sphinxparam{\DUrole{n}{kSteps}}\sphinxparamcomma \sphinxparam{\DUrole{n}{robot}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x0}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{Localization:Localization.Localization}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Localization}}}}}

\sphinxAtStartPar
Dead Reckoning Localization for a Differential Drive Mobile Robot.
\index{\_\_init\_\_() (DR\_3DOFDifferentialDrive.DR\_3DOFDifferentialDrive method)@\spxentry{\_\_init\_\_()}\spxextra{DR\_3DOFDifferentialDrive.DR\_3DOFDifferentialDrive method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{DRLocalization:DR_3DOFDifferentialDrive.DR_3DOFDifferentialDrive.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{n}{index}}\sphinxparamcomma \sphinxparam{\DUrole{n}{kSteps}}\sphinxparamcomma \sphinxparam{\DUrole{n}{robot}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x0}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Constructor of the {\hyperref[\detokenize{DRLocalization:DR_3DOFDifferentialDrive.DR_3DOFDifferentialDrive}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DR\_3DOFDifferentialDrive}}}}} class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{args}} \textendash{} Rest of arguments to be passed to the parent constructor

\end{description}\end{quote}

\end{fulllineitems}

\index{Localize() (DR\_3DOFDifferentialDrive.DR\_3DOFDifferentialDrive method)@\spxentry{Localize()}\spxextra{DR\_3DOFDifferentialDrive.DR\_3DOFDifferentialDrive method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{DRLocalization:DR_3DOFDifferentialDrive.DR_3DOFDifferentialDrive.Localize}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Localize}}}{\sphinxparam{\DUrole{n}{xk\_1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{uk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Motion model for the 3DOF (\(x_k=[x_{k}~y_{k}~\psi_{k}]^T\)) Differential Drive Mobile robot using as input the readings of the wheel encoders (\(u_k=[n_L~n_R]^T\)).
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_1}} \textendash{} previous robot pose estimate (\(x_{k-1}=[x_{k-1}~y_{k-1}~\psi_{k-1}]^T\))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{uk}} \textendash{} input vector (\(u_k=[u_{k}~v_{k}~r_{k}]^T\))

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{xk} current robot pose estimate (\([x_{k}~y_{k}~\psi_{k}]^T\))

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{GetInput() (DR\_3DOFDifferentialDrive.DR\_3DOFDifferentialDrive method)@\spxentry{GetInput()}\spxextra{DR\_3DOFDifferentialDrive.DR\_3DOFDifferentialDrive method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{DRLocalization:DR_3DOFDifferentialDrive.DR_3DOFDifferentialDrive.GetInput}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetInput}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Get the input for the motion model. In this case, the input is the robot displacement computed from the left and
right wheel encoders pulses using.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{uk:}  input vector (\(u_k={}^B[\Delta x~\Delta y]^T\))

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Grid Localization}
\label{\detokenize{Localization_index:grid-localization}}
\sphinxstepscope


\subsubsection{Grid Localization}
\label{\detokenize{GridLocalization:grid-localization}}\label{\detokenize{GridLocalization::doc}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{GL}.png}
\end{figure}
\index{GL (class in GL)@\spxentry{GL}\spxextra{class in GL}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL.GL}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{GL.}}\sphinxbfcode{\sphinxupquote{GL}}}{\sphinxparam{\DUrole{n}{p0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{index}}\sphinxparamcomma \sphinxparam{\DUrole{n}{kSteps}}\sphinxparamcomma \sphinxparam{\DUrole{n}{robot}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x0}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{HF:HF.HF}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{HF}}}}}

\sphinxAtStartPar
Grid Localization.
\index{\_\_init\_\_() (GL.GL method)@\spxentry{\_\_init\_\_()}\spxextra{GL.GL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL.GL.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{n}{p0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{index}}\sphinxparamcomma \sphinxparam{\DUrole{n}{kSteps}}\sphinxparamcomma \sphinxparam{\DUrole{n}{robot}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x0}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Constructor of the \sphinxcode{\sphinxupquote{GL\_4DOFAUV}} class. Initializes the Dead reckoning localization algorithm as well as the histogram filter algorithm.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dx\_max}} \textendash{} maximum x displacement in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dy\_max}} \textendash{} maximum y displacement in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{range\_dx}} \textendash{} range of x displacements in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{range\_dy}} \textendash{} range of y displacements in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{p0}} \textendash{} initial probability histogram

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} index struture containing plotting information

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kSteps}} \textendash{} number of time steps to simulate the robot motion

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{robot}} \textendash{} robot object

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x0}} \textendash{} initial robot pose

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{args}} \textendash{} additional arguments

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{GetMeasurements() (GL.GL method)@\spxentry{GetMeasurements()}\spxextra{GL.GL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL.GL.GetMeasurements}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetMeasurements}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Read the measurements from the robot.
This is a pure virtual method that must be implemented by the derived class.

\end{fulllineitems}

\index{StateTransitionProbability\_4\_uk() (GL.GL method)@\spxentry{StateTransitionProbability\_4\_uk()}\spxextra{GL.GL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL.GL.StateTransitionProbability_4_uk}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{StateTransitionProbability\_4\_uk}}}{\sphinxparam{\DUrole{n}{uk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Returns the state transition probability matrix for the given control input \sphinxstyleemphasis{uk}.
This is a pure virtual method that must be implemented by the derived class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{uk}} \textendash{} control input. In localization, this is commonly the robot displacement. For example, in the case of a differential drive robot, this is the robot displacement in the robot frame commonly computed through the odometry.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstyleemphasis{Puk} state transition probability matrix for a given uk

\end{description}\end{quote}

\end{fulllineitems}

\index{StateTransitionProbability() (GL.GL method)@\spxentry{StateTransitionProbability()}\spxextra{GL.GL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL.GL.StateTransitionProbability}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{StateTransitionProbability}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Computes the complete state transition probability matrix. The matrix is a \(n_u   imes m_u        imes n^2\) matrix,
where \(n_u\) and \(m_u\) are the number of possible displacements in the x and y axis, respectively, and
\(n\) is the number of cells in the map. For each possible displacement \(u_k\), each previous robot pose
\({x_{k-1}}\) and each current robot pose \({x_k}\), the probability \(p(x_k|x_{k-1},u_k)\) is computed.
This is a pure virtual method that must be implemented by the derived class.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
state transition probability matrix \(P_k=p{x_k|x_{k-1},uk}\)

\end{description}\end{quote}

\end{fulllineitems}

\index{MeasurementProbability() (GL.GL method)@\spxentry{MeasurementProbability()}\spxextra{GL.GL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL.GL.MeasurementProbability}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{MeasurementProbability}}}{\sphinxparam{\DUrole{n}{zk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Computes the measurement probability histogram given the robot pose \(\eta_k\) and the measurement \(z_k\).
Method to be overriden by the child class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{zk}} \textendash{} vector of measurements

\sphinxlineitem{Returns}
\sphinxAtStartPar
Measurement probability histogram \(p_z=p(z_k | \eta_k)\)

\end{description}\end{quote}

\end{fulllineitems}

\index{GetInput() (GL.GL method)@\spxentry{GetInput()}\spxextra{GL.GL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL.GL.GetInput}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetInput}}}{\sphinxparam{\DUrole{n}{usk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Gets the number of cells the robot has displaced along its DOFs in the world N\sphinxhyphen{}Frame.
Method to be overriden by the child class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{usk}} \textendash{} control input of the robot simulation

\sphinxlineitem{Returns}
\sphinxAtStartPar
uk: vector containing the number of cells the robot has displaced in all the axis of the world N\sphinxhyphen{}Frame

\end{description}\end{quote}

\end{fulllineitems}

\index{uk2cell() (GL.GL method)@\spxentry{uk2cell()}\spxextra{GL.GL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL.GL.uk2cell}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{uk2cell}}}{\sphinxparam{\DUrole{n}{uk}}}{}
\pysigstopsignatures\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{uk}} \textendash{} 

\sphinxlineitem{Returns}
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{LocalizationLoop() (GL.GL method)@\spxentry{LocalizationLoop()}\spxextra{GL.GL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL.GL.LocalizationLoop}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{LocalizationLoop}}}{\sphinxparam{\DUrole{n}{p0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{usk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Given an initial robot pose \(x_0\) and the input to the \sphinxcode{\sphinxupquote{AUV4DOFSimulatedRobot.SimulatedRobot}} this method calls iteratively \sphinxcode{\sphinxupquote{GL\_4DOFAUV.Localize()}} for k steps, solving the robot localization problem.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{p0}} \textendash{} initial robot pose

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{usk}} \textendash{} control input of the robot simulation

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{Localize() (GL.GL method)@\spxentry{Localize()}\spxextra{GL.GL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL.GL.Localize}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Localize}}}{\sphinxparam{\DUrole{n}{pxk\_1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{uk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{zk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Overrides the parent method \sphinxcode{\sphinxupquote{DR\_4DOFAUV\_DVLGyro.Localize()}}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pxk\_1}} \textendash{} histogram of the previous robot position

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{uk}} \textendash{} robot displacement in number of cells in the world N\sphinxhyphen{}Frame

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{zk}} \textendash{} vector containing the measurements of the robot position in the world N\sphinxhyphen{}Frame

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
pk: histogram of the robot position after the prediction and the update steps

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{4 DOF AUV}
\label{\detokenize{GridLocalization:dof-auv}}

\paragraph{AUV Grid Localization Example}
\label{\detokenize{GridLocalization:auv-grid-localization-example}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{GL_4DOFAUV}.png}
\end{figure}
\index{GL\_4DOFAUV (class in GL\_4DOFAUV)@\spxentry{GL\_4DOFAUV}\spxextra{class in GL\_4DOFAUV}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL_4DOFAUV.GL_4DOFAUV}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{GL\_4DOFAUV.}}\sphinxbfcode{\sphinxupquote{GL\_4DOFAUV}}}{\sphinxparam{\DUrole{n}{dx\_max}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dy\_max}}\sphinxparamcomma \sphinxparam{\DUrole{n}{range\_dx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{range\_dy}}\sphinxparamcomma \sphinxparam{\DUrole{n}{p0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{index}}\sphinxparamcomma \sphinxparam{\DUrole{n}{kSteps}}\sphinxparamcomma \sphinxparam{\DUrole{n}{robot}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x0}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{GridLocalization:GL.GL}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GL}}}}}, {\hyperref[\detokenize{DRLocalization:DR_4DOFAUV_DVLGyro.DR_4DOFAUV_DVLGyro}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DR\_4DOFAUV\_DVLGyro}}}}}

\sphinxAtStartPar
Grid Reckoning Localization for a 4 DOF AUV.
\index{\_\_init\_\_() (GL\_4DOFAUV.GL\_4DOFAUV method)@\spxentry{\_\_init\_\_()}\spxextra{GL\_4DOFAUV.GL\_4DOFAUV method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL_4DOFAUV.GL_4DOFAUV.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{n}{dx\_max}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dy\_max}}\sphinxparamcomma \sphinxparam{\DUrole{n}{range\_dx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{range\_dy}}\sphinxparamcomma \sphinxparam{\DUrole{n}{p0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{index}}\sphinxparamcomma \sphinxparam{\DUrole{n}{kSteps}}\sphinxparamcomma \sphinxparam{\DUrole{n}{robot}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x0}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Constructor of the {\hyperref[\detokenize{GridLocalization:GL_4DOFAUV.GL_4DOFAUV}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GL\_4DOFAUV}}}}} class. Initializes the Dead reckoning localization algorithm as well as the histogram filter algorithm.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dx\_max}} \textendash{} maximum x displacement in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dy\_max}} \textendash{} maximum y displacement in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{range\_dx}} \textendash{} range of x displacements in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{range\_dy}} \textendash{} range of y displacements in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{p0}} \textendash{} initial probability histogram

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} index struture containing plotting information

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kSteps}} \textendash{} number of time steps to simulate the robot motion

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{robot}} \textendash{} robot object

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x0}} \textendash{} initial robot pose

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{args}} \textendash{} additional arguments

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{GetMeasurements() (GL\_4DOFAUV.GL\_4DOFAUV method)@\spxentry{GetMeasurements()}\spxextra{GL\_4DOFAUV.GL\_4DOFAUV method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL_4DOFAUV.GL_4DOFAUV.GetMeasurements}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetMeasurements}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Read the measurements from the robot. Returns a vector of range distances to the map features.
Only those features that are within the \sphinxcode{\sphinxupquote{SimulatedRobot.SimulatedRobot.Distance\_max\_range}} of the sensor are returned.
The measurements arribe at a frequency defined in the \sphinxcode{\sphinxupquote{SimulatedRobot.SimulatedRobot.Distance\_feature\_reading\_frequency}} attribute.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
vector of distances to the map features

\end{description}\end{quote}

\end{fulllineitems}

\index{StateTransitionProbability\_4\_uk() (GL\_4DOFAUV.GL\_4DOFAUV method)@\spxentry{StateTransitionProbability\_4\_uk()}\spxextra{GL\_4DOFAUV.GL\_4DOFAUV method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL_4DOFAUV.GL_4DOFAUV.StateTransitionProbability_4_uk}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{StateTransitionProbability\_4\_uk}}}{\sphinxparam{\DUrole{n}{uk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Returns the state transition probability matrix for the given control input \sphinxstyleemphasis{uk}.
This is a pure virtual method that must be implemented by the derived class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{uk}} \textendash{} control input. In localization, this is commonly the robot displacement. For example, in the case of a differential drive robot, this is the robot displacement in the robot frame commonly computed through the odometry.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstyleemphasis{Puk} state transition probability matrix for a given uk

\end{description}\end{quote}

\end{fulllineitems}

\index{StateTransitionProbability\_4\_xk\_1\_uk() (GL\_4DOFAUV.GL\_4DOFAUV method)@\spxentry{StateTransitionProbability\_4\_xk\_1\_uk()}\spxextra{GL\_4DOFAUV.GL\_4DOFAUV method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL_4DOFAUV.GL_4DOFAUV.StateTransitionProbability_4_xk_1_uk}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{StateTransitionProbability\_4\_xk\_1\_uk}}}{\sphinxparam{\DUrole{n}{etak\_1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{uk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Computes the state transition probability histogram given the previous robot pose \(\eta_{k-1}\) and the input \(u_k\):
\begin{equation*}
\begin{split}p(\eta_k | \eta_{k-1}, u_k)\end{split}
\end{equation*}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{etak\_1}} \textendash{} previous robot pose in cells

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{uk}} \textendash{} input displacement in number of cells

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
state transition probability \(p(\eta_k | \eta_{k-1}, u_k)\)

\end{description}\end{quote}

\end{fulllineitems}

\index{StateTransitionProbability() (GL\_4DOFAUV.GL\_4DOFAUV method)@\spxentry{StateTransitionProbability()}\spxextra{GL\_4DOFAUV.GL\_4DOFAUV method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL_4DOFAUV.GL_4DOFAUV.StateTransitionProbability}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{StateTransitionProbability}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Computes the complete state transition probability matrix. The matrix is a \(n_u   imes m_u        imes n^2\) matrix,
where \(n_u\) and \(m_u\) are the number of possible displacements in the x and y axis, respectively, and
\(n\) is the number of cells in the map. For each possible displacement \(u_k\), each previous robot pose
\({x_{k-1}}\) and each current robot pose \({x_k}\), the probability \(p(x_k|x_{k-1},u_k)\) is computed.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
state transition probability matrix \(P_k=p{x_k|x_{k-1},uk}\)

\end{description}\end{quote}

\end{fulllineitems}

\index{uk2cell() (GL\_4DOFAUV.GL\_4DOFAUV method)@\spxentry{uk2cell()}\spxextra{GL\_4DOFAUV.GL\_4DOFAUV method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL_4DOFAUV.GL_4DOFAUV.uk2cell}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{uk2cell}}}{\sphinxparam{\DUrole{n}{uk}}}{}
\pysigstopsignatures\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{uk}} \textendash{} 

\sphinxlineitem{Returns}
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{MeasurementProbability() (GL\_4DOFAUV.GL\_4DOFAUV method)@\spxentry{MeasurementProbability()}\spxextra{GL\_4DOFAUV.GL\_4DOFAUV method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL_4DOFAUV.GL_4DOFAUV.MeasurementProbability}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{MeasurementProbability}}}{\sphinxparam{\DUrole{n}{zk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Computes the measurement probability histogram given the robot pose \(\eta_k\) and the measurement \(z_k\).
In this case the the measurement is the vector of the distances to the landmarks in the map.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{zk}} \textendash{} \(z_k=[r_0~r_1~..r_k]\) where \(r_i\) is the distance to the i\sphinxhyphen{}th landmark in the map.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Measurement probability histogram \(p_z=p(z_k | \eta_k)\)

\end{description}\end{quote}

\end{fulllineitems}

\index{GetInput() (GL\_4DOFAUV.GL\_4DOFAUV method)@\spxentry{GetInput()}\spxextra{GL\_4DOFAUV.GL\_4DOFAUV method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL_4DOFAUV.GL_4DOFAUV.GetInput}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetInput}}}{\sphinxparam{\DUrole{n}{usk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Provides an implementation for the virtual method \sphinxcode{\sphinxupquote{GL.GetInput()}}.
Gets the number of cells the robot has displaced in the x and y directions in the world N\sphinxhyphen{}Frame. To do it, it
calls several times the parent method \sphinxcode{\sphinxupquote{super().GetInput()}}, corresponding to the Dead Reckoning Localization
of the robot, until it has displaced at least one cell in any direction.
Note that an iteration of the robot simulation \sphinxcode{\sphinxupquote{SimulatedRobot.fs()}} is normally done in the \sphinxcode{\sphinxupquote{GL\_4DOFAUV.LocalizationLoop()}}
method of the \sphinxcode{\sphinxupquote{GL\_4DOFAUV.Localization}} class, but in this case it is done here to simulate the robot motion
between the consecutive calls to \sphinxcode{\sphinxupquote{super().GetInput()}}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{usk}} \textendash{} control input of the robot simulation

\sphinxlineitem{Returns}
\sphinxAtStartPar
uk: vector containing the number of cells the robot has displaced in the x and y directions in the world N\sphinxhyphen{}Frame

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{3 DOF Differential Drive Mobile Robot}
\label{\detokenize{GridLocalization:dof-differential-drive-mobile-robot}}

\paragraph{Differential Drive Grid Localization Example}
\label{\detokenize{GridLocalization:differential-drive-grid-localization-example}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{GL_3DOFDifferentialDrive}.png}
\end{figure}
\index{GL\_3DOFDifferentialDrive (class in GL\_3DOFDifferentialDrive)@\spxentry{GL\_3DOFDifferentialDrive}\spxextra{class in GL\_3DOFDifferentialDrive}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL_3DOFDifferentialDrive.GL_3DOFDifferentialDrive}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{GL\_3DOFDifferentialDrive.}}\sphinxbfcode{\sphinxupquote{GL\_3DOFDifferentialDrive}}}{\sphinxparam{\DUrole{n}{dx\_max}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dy\_max}}\sphinxparamcomma \sphinxparam{\DUrole{n}{range\_dx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{range\_dy}}\sphinxparamcomma \sphinxparam{\DUrole{n}{p0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{index}}\sphinxparamcomma \sphinxparam{\DUrole{n}{kSteps}}\sphinxparamcomma \sphinxparam{\DUrole{n}{robot}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x0}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{GridLocalization:GL.GL}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GL}}}}}, {\hyperref[\detokenize{DRLocalization:DR_3DOFDifferentialDrive.DR_3DOFDifferentialDrive}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DR\_3DOFDifferentialDrive}}}}}

\sphinxAtStartPar
Grid Reckoning Localization for a 4 DOF AUV.
\index{\_\_init\_\_() (GL\_3DOFDifferentialDrive.GL\_3DOFDifferentialDrive method)@\spxentry{\_\_init\_\_()}\spxextra{GL\_3DOFDifferentialDrive.GL\_3DOFDifferentialDrive method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL_3DOFDifferentialDrive.GL_3DOFDifferentialDrive.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{n}{dx\_max}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dy\_max}}\sphinxparamcomma \sphinxparam{\DUrole{n}{range\_dx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{range\_dy}}\sphinxparamcomma \sphinxparam{\DUrole{n}{p0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{index}}\sphinxparamcomma \sphinxparam{\DUrole{n}{kSteps}}\sphinxparamcomma \sphinxparam{\DUrole{n}{robot}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x0}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Constructor of the \sphinxcode{\sphinxupquote{GL\_4DOFAUV}} class. Initializes the Dead reckoning localization algorithm as well as the histogram filter algorithm.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dx\_max}} \textendash{} maximum x displacement in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dy\_max}} \textendash{} maximum y displacement in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{range\_dx}} \textendash{} range of x displacements in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{range\_dy}} \textendash{} range of y displacements in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{p0}} \textendash{} initial probability histogram

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} index struture containing plotting information

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kSteps}} \textendash{} number of time steps to simulate the robot motion

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{robot}} \textendash{} robot object

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x0}} \textendash{} initial robot pose

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{args}} \textendash{} additional arguments

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{GetMeasurements() (GL\_3DOFDifferentialDrive.GL\_3DOFDifferentialDrive method)@\spxentry{GetMeasurements()}\spxextra{GL\_3DOFDifferentialDrive.GL\_3DOFDifferentialDrive method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL_3DOFDifferentialDrive.GL_3DOFDifferentialDrive.GetMeasurements}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetMeasurements}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Read the measurements from the robot. Returns a vector of range distances to the map features.
Only those features that are within the \sphinxcode{\sphinxupquote{SimulatedRobot.SimulatedRobot.Distance\_max\_range}} of the sensor are returned.
The measurements arribe at a frequency defined in the \sphinxcode{\sphinxupquote{SimulatedRobot.SimulatedRobot.Distance\_feature\_reading\_frequency}} attribute.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
vector of distances to the map features

\end{description}\end{quote}

\end{fulllineitems}

\index{StateTransitionProbability\_4\_uk() (GL\_3DOFDifferentialDrive.GL\_3DOFDifferentialDrive method)@\spxentry{StateTransitionProbability\_4\_uk()}\spxextra{GL\_3DOFDifferentialDrive.GL\_3DOFDifferentialDrive method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL_3DOFDifferentialDrive.GL_3DOFDifferentialDrive.StateTransitionProbability_4_uk}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{StateTransitionProbability\_4\_uk}}}{\sphinxparam{\DUrole{n}{uk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Returns the state transition probability matrix for the given control input \sphinxstyleemphasis{uk}.
This is a pure virtual method that must be implemented by the derived class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{uk}} \textendash{} control input. In localization, this is commonly the robot displacement. For example, in the case of a differential drive robot, this is the robot displacement in the robot frame commonly computed through the odometry.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstyleemphasis{Puk} state transition probability matrix for a given uk

\end{description}\end{quote}

\end{fulllineitems}

\index{StateTransitionProbability\_4\_xk\_1\_uk() (GL\_3DOFDifferentialDrive.GL\_3DOFDifferentialDrive method)@\spxentry{StateTransitionProbability\_4\_xk\_1\_uk()}\spxextra{GL\_3DOFDifferentialDrive.GL\_3DOFDifferentialDrive method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL_3DOFDifferentialDrive.GL_3DOFDifferentialDrive.StateTransitionProbability_4_xk_1_uk}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{StateTransitionProbability\_4\_xk\_1\_uk}}}{\sphinxparam{\DUrole{n}{etak\_1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{uk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Computes the state transition probability histogram given the previous robot pose \(\eta_{k-1}\) and the input \(u_k\):
\begin{equation*}
\begin{split}p(\eta_k | \eta_{k-1}, u_k)\end{split}
\end{equation*}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{etak\_1}} \textendash{} previous robot pose in cells

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{uk}} \textendash{} input displacement in number of cells

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
state transition probability \(p(\eta_k | \eta_{k-1}, u_k)\)

\end{description}\end{quote}

\end{fulllineitems}

\index{StateTransitionProbability() (GL\_3DOFDifferentialDrive.GL\_3DOFDifferentialDrive method)@\spxentry{StateTransitionProbability()}\spxextra{GL\_3DOFDifferentialDrive.GL\_3DOFDifferentialDrive method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL_3DOFDifferentialDrive.GL_3DOFDifferentialDrive.StateTransitionProbability}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{StateTransitionProbability}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Computes the complete state transition probability matrix. The matrix is a \(n_u   imes m_u        imes n^2\) matrix,
where \(n_u\) and \(m_u\) are the number of possible displacements in the x and y axis, respectively, and
\(n\) is the number of cells in the map. For each possible displacement \(u_k\), each previous robot pose
\({x_{k-1}}\) and each current robot pose \({x_k}\), the probability \(p(x_k|x_{k-1},u_k)\) is computed.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
state transition probability matrix \(P_k=p{x_k|x_{k-1},uk}\)

\end{description}\end{quote}

\end{fulllineitems}

\index{uk2cell() (GL\_3DOFDifferentialDrive.GL\_3DOFDifferentialDrive method)@\spxentry{uk2cell()}\spxextra{GL\_3DOFDifferentialDrive.GL\_3DOFDifferentialDrive method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL_3DOFDifferentialDrive.GL_3DOFDifferentialDrive.uk2cell}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{uk2cell}}}{\sphinxparam{\DUrole{n}{uk}}}{}
\pysigstopsignatures\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{uk}} \textendash{} 

\sphinxlineitem{Returns}
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{MeasurementProbability() (GL\_3DOFDifferentialDrive.GL\_3DOFDifferentialDrive method)@\spxentry{MeasurementProbability()}\spxextra{GL\_3DOFDifferentialDrive.GL\_3DOFDifferentialDrive method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL_3DOFDifferentialDrive.GL_3DOFDifferentialDrive.MeasurementProbability}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{MeasurementProbability}}}{\sphinxparam{\DUrole{n}{zk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Computes the measurement probability histogram given the robot pose \(\eta_k\) and the measurement \(z_k\).
In this case the the measurement is the vector of the distances to the landmarks in the map.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{zk}} \textendash{} \(z_k=[r_0~r_1~..r_k]\) where \(r_i\) is the distance to the i\sphinxhyphen{}th landmark in the map.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Measurement probability histogram \(p_z=p(z_k | \eta_k)\)

\end{description}\end{quote}

\end{fulllineitems}

\index{GetInput() (GL\_3DOFDifferentialDrive.GL\_3DOFDifferentialDrive method)@\spxentry{GetInput()}\spxextra{GL\_3DOFDifferentialDrive.GL\_3DOFDifferentialDrive method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridLocalization:GL_3DOFDifferentialDrive.GL_3DOFDifferentialDrive.GetInput}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetInput}}}{\sphinxparam{\DUrole{n}{usk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Provides an implementation for the virtual method \sphinxcode{\sphinxupquote{GL.GetInput()}}.
Gets the number of cells the robot has displaced in the x and y directions in the world N\sphinxhyphen{}Frame. To do it, it
calls several times the parent method \sphinxcode{\sphinxupquote{super().GetInput()}}, corresponding to the Dead Reckoning Localization
of the robot, until it has displaced at least one cell in any direction.
Note that an iteration of the robot simulation \sphinxcode{\sphinxupquote{SimulatedRobot.fs()}} is normally done in the \sphinxcode{\sphinxupquote{GL\_4DOFAUV.LocalizationLoop()}}
method of the \sphinxcode{\sphinxupquote{GL\_4DOFAUV.Localization}} class, but in this case it is done here to simulate the robot motion
between the consecutive calls to \sphinxcode{\sphinxupquote{super().GetInput()}}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{usk}} \textendash{} control input of the robot simulation

\sphinxlineitem{Returns}
\sphinxAtStartPar
uk: vector containing the number of cells the robot has displaced in the x and y directions in the world N\sphinxhyphen{}Frame

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Montecarlo Localization}
\label{\detokenize{Localization_index:montecarlo-localization}}
\sphinxstepscope


\subsubsection{Montecarlo Localization}
\label{\detokenize{MCLLocalization:montecarlo-localization}}\label{\detokenize{MCLLocalization::doc}}
\sphinxAtStartPar
To be completed


\subsection{Gaussian Filter  Localization}
\label{\detokenize{Localization_index:gaussian-filter-localization}}
\sphinxstepscope


\subsubsection{Gaussian Filter Localization}
\label{\detokenize{GFLocalization:gaussian-filter-localization}}\label{\detokenize{GFLocalization::doc}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{GFLocalization}.png}
\end{figure}
\index{GFLocalization (class in GFLocalization)@\spxentry{GFLocalization}\spxextra{class in GFLocalization}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:GFLocalization.GFLocalization}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{GFLocalization.}}\sphinxbfcode{\sphinxupquote{GFLocalization}}}{\sphinxparam{\DUrole{n}{index}}\sphinxparamcomma \sphinxparam{\DUrole{n}{kSteps}}\sphinxparamcomma \sphinxparam{\DUrole{n}{robot}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{P0}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{Localization:Localization.Localization}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Localization}}}}}, \sphinxcode{\sphinxupquote{GaussianFilter}}

\sphinxAtStartPar
Map\sphinxhyphen{}less localization using KF and EKF filters.
\index{\_\_init\_\_() (GFLocalization.GFLocalization method)@\spxentry{\_\_init\_\_()}\spxextra{GFLocalization.GFLocalization method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:GFLocalization.GFLocalization.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{n}{index}}\sphinxparamcomma \sphinxparam{\DUrole{n}{kSteps}}\sphinxparamcomma \sphinxparam{\DUrole{n}{robot}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{P0}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Constructor.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x0}} \textendash{} initial state

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{P0}} \textendash{} initial covariance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} Named tuple used to map the state vector, the simulation vector and the observation vector (\sphinxcode{\sphinxupquote{prpy.IndexStruct}})

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kSteps}} \textendash{} simulation time steps

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{robot}} \textendash{} Simulated Robot object

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{args}} \textendash{} arguments to be passed to the parent constructor

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{GetInput() (GFLocalization.GFLocalization method)@\spxentry{GetInput()}\spxextra{GFLocalization.GFLocalization method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:GFLocalization.GFLocalization.GetInput}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetInput}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Get the input from the robot. Relates to the motion model as follows:
\begin{equation}\label{equation:GFLocalization:eq-f-GFLocalization}
\begin{split}x_k &= f(x_{k-1},u_k,w_k) \\
w_k &= N(0,Q_k)\end{split}
\end{equation}
\sphinxAtStartPar
\sphinxstylestrong{To be overidden by the child class} .
\begin{quote}\begin{description}
\sphinxlineitem{Return uk, Qk}
\sphinxAtStartPar
input and covariance of the motion model

\end{description}\end{quote}

\end{fulllineitems}

\index{GetMeasurements() (GFLocalization.GFLocalization method)@\spxentry{GetMeasurements()}\spxextra{GFLocalization.GFLocalization method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:GFLocalization.GFLocalization.GetMeasurements}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetMeasurements}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Get the measurements from the robot. Corresponds to the observation model:
\begin{equation}\label{equation:GFLocalization:eq-h}
\begin{split}z_k &= h(x_{k},v_k) \\
v_k &= N(0,R_k)\end{split}
\end{equation}
\sphinxAtStartPar
\sphinxstylestrong{To be overidden by the child class} .
\begin{quote}\begin{description}
\sphinxlineitem{Return zk, Rk}
\sphinxAtStartPar
observation vector and covariance of the observation noise.

\end{description}\end{quote}

\end{fulllineitems}

\index{Localize() (GFLocalization.GFLocalization method)@\spxentry{Localize()}\spxextra{GFLocalization.GFLocalization method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:GFLocalization.GFLocalization.Localize}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Localize}}}{\sphinxparam{\DUrole{n}{xk\_1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Pk\_1}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Localization iteration. Reads the input of the motion model, performs the prediction step, reads the measurements, performs the update step and logs the results.
The method also plots the uncertainty ellipse of the robot pose.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_1}} \textendash{} previous state vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Pk\_1}} \textendash{} previous covariance matrix

\end{itemize}

\sphinxlineitem{Return xk, Pk}
\sphinxAtStartPar
updated state vector and covariance matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{LocalizationLoop() (GFLocalization.GFLocalization method)@\spxentry{LocalizationLoop()}\spxextra{GFLocalization.GFLocalization method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:GFLocalization.GFLocalization.LocalizationLoop}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{LocalizationLoop}}}{\sphinxparam{\DUrole{n}{x0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{P0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{usk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Localization loop. During \sphinxstyleemphasis{self.kSteps} it calls the {\hyperref[\detokenize{GFLocalization:GFLocalization.GFLocalization.Localize}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Localize()}}}}} method for each time step.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x0}} \textendash{} initial state vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{P0}} \textendash{} initial covariance matrix

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{Log() (GFLocalization.GFLocalization method)@\spxentry{Log()}\spxextra{GFLocalization.GFLocalization method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:GFLocalization.GFLocalization.Log}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Log}}}{\sphinxparam{\DUrole{n}{xsk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{xk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Pk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{xk\_bar}}\sphinxparamcomma \sphinxparam{\DUrole{n}{zk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Logs the results for later plotting.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xsk}} \textendash{} ground truth robot pose from the simulation

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk}} \textendash{} estimated robot pose

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{PlotState() (GFLocalization.GFLocalization method)@\spxentry{PlotState()}\spxextra{GFLocalization.GFLocalization method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:GFLocalization.GFLocalization.PlotState}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{PlotState}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Plot the results of the localization
For each state DOF s
\sphinxhyphen{}si{[}s{]} is the corresponding simulated stated
\sphinxhyphen{}x1{[}s{]} is the corresponding observation

\end{fulllineitems}

\index{PlotXY() (GFLocalization.GFLocalization method)@\spxentry{PlotXY()}\spxextra{GFLocalization.GFLocalization method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:GFLocalization.GFLocalization.PlotXY}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{PlotXY}}}{\sphinxparam{\DUrole{n}{estimation}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Plot the x\sphinxhyphen{}y trajectory of the robot
simulation: True if the simulated XY robot trajectory is available

\end{fulllineitems}

\index{PlotRobotUncertainty() (GFLocalization.GFLocalization method)@\spxentry{PlotRobotUncertainty()}\spxextra{GFLocalization.GFLocalization method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:GFLocalization.GFLocalization.PlotRobotUncertainty}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{PlotRobotUncertainty}}}{\sphinxparam{\DUrole{n}{xk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Pk}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{PlotUncertainty() (GFLocalization.GFLocalization method)@\spxentry{PlotUncertainty()}\spxextra{GFLocalization.GFLocalization method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:GFLocalization.GFLocalization.PlotUncertainty}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{PlotUncertainty}}}{\sphinxparam{\DUrole{n}{xk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Pk}}}{}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}



\subsubsection{4 DOF AUV}
\label{\detokenize{GFLocalization:dof-auv}}

\paragraph{4 DOF AUV EKF Localization using an Input Velocity Motion Model with Depht, Yaw and Linear Velocity Measurements}
\label{\detokenize{GFLocalization:dof-auv-ekf-localization-using-an-input-velocity-motion-model-with-depht-yaw-and-linear-velocity-measurements}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{EKF_4DOFAUV_InputVelocityMM_DVLDepthYawOM}.png}
\end{figure}
\index{EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM (class in EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM)@\spxentry{EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM}\spxextra{class in EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_4DOFAUV_InputVelocityMM_DVLDepthYawOM.EKF_4DOFAUV_InputVelocityMM_DVLDepthYawOM}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM.}}\sphinxbfcode{\sphinxupquote{EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM}}}{\sphinxparam{\DUrole{n}{kSteps}}\sphinxparamcomma \sphinxparam{\DUrole{n}{robot}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{GFLocalization:GFLocalization.GFLocalization}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GFLocalization}}}}}, {\hyperref[\detokenize{DRLocalization:DR_4DOFAUV_DVLGyro.DR_4DOFAUV_DVLGyro}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DR\_4DOFAUV\_DVLGyro}}}}}, {\hyperref[\detokenize{EKF:EKF.EKF}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{EKF}}}}}

\sphinxAtStartPar
This class implements an EKF localization filter for a 4 DOF AUV using an input velocity motion model  incorporating
DVL linear velocity measurements, a gyro angular speed measurement, as well as depth and yaw measurements.
Inherits from GFLocalization because it is a Localization method using Gaussian filtering, and from EKF because it uses an EKF.
It also inherits from DR\_4DOFAUV\_DVLGyro to reuse its motion model \sphinxcode{\sphinxupquote{solved\_prlab.DR\_4DOFAUV\_DVLGyro.Localize()}} and the model input \sphinxcode{\sphinxupquote{solved\_prlab.DR\_4DOFAUV\_DVLGyro.GetInput()}}.
\index{\_\_init\_\_() (EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM method)@\spxentry{\_\_init\_\_()}\spxextra{EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_4DOFAUV_InputVelocityMM_DVLDepthYawOM.EKF_4DOFAUV_InputVelocityMM_DVLDepthYawOM.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{n}{kSteps}}\sphinxparamcomma \sphinxparam{\DUrole{n}{robot}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Constructor.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{args}} \textendash{} arguments to be passed to the base class constructor

\end{description}\end{quote}

\end{fulllineitems}

\index{f() (EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM method)@\spxentry{f()}\spxextra{EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_4DOFAUV_InputVelocityMM_DVLDepthYawOM.EKF_4DOFAUV_InputVelocityMM_DVLDepthYawOM.f}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{f}}}{\sphinxparam{\DUrole{n}{xk\_1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{uk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Non\sphinxhyphen{}linear motion model using as input the DVL linear velocity and the gyro angular speed:
\begin{equation*}
\begin{split}x_k&=f(x_{k-1},u_k,w_k) = x_{k-1} \oplus (u_k + w_k) \Delta t \\
x_{k-1}&=[x_{k_1}^T, y_{k_1}^T, z_{k_1}^T, \psi_{k_1}^T]^T\\
u_k&=[u_k, v_k, w_k, r_k]^T\end{split}
\end{equation*}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_1}} \textendash{} previous mean state vector (\(x_{k-1}=[x_{k-1}^T, y_{k-1}^T, z_{k-1}^T, \psi_{k-1}^T]^T\)) containing the robot position and heading in the N\sphinxhyphen{}Frame

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{uk}} \textendash{} input vector \(u_k=[u_k^T, v_k^T, w_k^T, r_k^T]^T\) containing the DVL linear velocity and the gyro angular speed, both referenced in the B\sphinxhyphen{}Frame

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
current mean state vector containing the current robot position and heading (\(x_k=[x_k^T, y_k^T, z_k^T, \psi_k^T]^T\)) represented in the N\sphinxhyphen{}Frame

\end{description}\end{quote}

\end{fulllineitems}

\index{Jfx() (EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM method)@\spxentry{Jfx()}\spxextra{EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_4DOFAUV_InputVelocityMM_DVLDepthYawOM.EKF_4DOFAUV_InputVelocityMM_DVLDepthYawOM.Jfx}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Jfx}}}{\sphinxparam{\DUrole{n}{xk\_1}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the motion model with respect to the state vector:
\begin{equation}\label{equation:GFLocalization:eq-Jfx-EKF_4DOFAUV_VelocityMM_DVLDepthYawOM}
\begin{split}J_{fx}=\frac{\partial f(x_{k-1},u_k,w_k)}{\partial x_{k-1}} = \frac{\partial x_{k-1} \oplus (u_k + w_k)}{\partial x_{k-1}} = J_{1\oplus}\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_1}} \textendash{} Linearization point. By default the linearization point is the previous state vector taken from a class attribute.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{Jfw() (EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM method)@\spxentry{Jfw()}\spxextra{EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_4DOFAUV_InputVelocityMM_DVLDepthYawOM.EKF_4DOFAUV_InputVelocityMM_DVLDepthYawOM.Jfw}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Jfw}}}{\sphinxparam{\DUrole{n}{xk\_1}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the motion model with respect to the motion model noise vector:
\begin{equation}\label{equation:GFLocalization:eq-Jfw-EKF_4DOFAUV_VelocityMM_DVLDepthYawOM}
\begin{split}J_{fx}=\frac{\partial f(x_{k-1},u_k,w_k)}{\partial w_k} = \frac{\partial x_{k-1} \oplus (u_k + w_k)}{\partial w_k} = J_{2\oplus}\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_1}} \textendash{} Linearization point. By default the linearization point is the previous state vector taken from a class attribute.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{hm() (EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM method)@\spxentry{hm()}\spxextra{EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_4DOFAUV_InputVelocityMM_DVLDepthYawOM.EKF_4DOFAUV_InputVelocityMM_DVLDepthYawOM.hm}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{hm}}}{\sphinxparam{\DUrole{n}{xk\_bar}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Observation model related to the measurements observations of the EKF to be overwritten by the child class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_bar}} \textendash{} mean of the predicted state vector. By default it is taken from the class attribute.

\sphinxlineitem{Returns}
\sphinxAtStartPar
expected observation vector

\end{description}\end{quote}

\end{fulllineitems}

\index{Jhmx() (EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM method)@\spxentry{Jhmx()}\spxextra{EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_4DOFAUV_InputVelocityMM_DVLDepthYawOM.EKF_4DOFAUV_InputVelocityMM_DVLDepthYawOM.Jhmx}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Jhmx}}}{\sphinxparam{\DUrole{n}{xk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the measurement model with respect to the state vector:
\begin{equation}\label{equation:GFLocalization:eq-Jhmx-EKF_4DOFAUV_VelocityMM_DVLDepthYawOM}
\begin{split}J_{hmx}=H_{m_k}=\frac{\partial h_m(x_k,v_k)}{\partial x_k} = \frac{\partial [z_{depth}^T, \psi_{compass}^T]^T}{\partial x_k}
=\begin{bmatrix} 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk}} \textendash{} mean state vector containing the robot position and heading (\(x_k=[x_k^T, y_k^T, z_k^T, \psi_k^T]^T\)) represented in the N\sphinxhyphen{}Frame

\sphinxlineitem{Returns}
\sphinxAtStartPar
observation matrix (Jacobian) matrix eq. \eqref{equation:GFLocalization:eq-Jhmx-EKF_4DOFAUV_VelocityMM_DVLDepthYawOM}.

\end{description}\end{quote}

\end{fulllineitems}

\index{Jhmv() (EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM method)@\spxentry{Jhmv()}\spxextra{EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_4DOFAUV_InputVelocityMM_DVLDepthYawOM.EKF_4DOFAUV_InputVelocityMM_DVLDepthYawOM.Jhmv}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Jhmv}}}{\sphinxparam{\DUrole{n}{xk\_bar}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the measurement model with respect to the measurement noise vector:
\begin{equation}\label{equation:GFLocalization:eq-Jhmv-EKF4DOFAUVVelocityMMDVLDepthYawOM}
\begin{split}J_{hmv}=V_{m_k}=\frac{\partial h_m(x_k,v_k)}{\partial v_k} = I_{2 \times 2}\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk}} \textendash{} mean state vector containing the robot position and heading (\(x_k=[x_k^T, y_k^T, z_k^T, \psi_k^T]^T\)) represented in the N\sphinxhyphen{}Frame

\sphinxlineitem{Returns}
\sphinxAtStartPar
observation noise (Jacobian) matrix eq. \eqref{equation:GFLocalization:eq-Jhmv-EKF4DOFAUVVelocityMMDVLDepthYawOM}.

\end{description}\end{quote}

\end{fulllineitems}

\index{GetInput() (EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM method)@\spxentry{GetInput()}\spxextra{EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_4DOFAUV_InputVelocityMM_DVLDepthYawOM.EKF_4DOFAUV_InputVelocityMM_DVLDepthYawOM.GetInput}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetInput}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Get the input from the robot. Relates to the motion model as follows:
\begin{equation}\label{equation:GFLocalization:eq-f-GFLocalization}
\begin{split}x_k &= f(x_{k-1},u_k,w_k) \\
w_k &= N(0,Q_k)\end{split}
\end{equation}
\sphinxAtStartPar
\sphinxstylestrong{To be overidden by the child class} .
\begin{quote}\begin{description}
\sphinxlineitem{Return uk, Qk}
\sphinxAtStartPar
input and covariance of the motion model

\end{description}\end{quote}

\end{fulllineitems}

\index{GetMeasurements() (EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM method)@\spxentry{GetMeasurements()}\spxextra{EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_InputVelocityMM\_DVLDepthYawOM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_4DOFAUV_InputVelocityMM_DVLDepthYawOM.EKF_4DOFAUV_InputVelocityMM_DVLDepthYawOM.GetMeasurements}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetMeasurements}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Get the measurements from the robot. Corresponds to the observation model:
\begin{equation}\label{equation:GFLocalization:eq-h}
\begin{split}z_k &= h(x_{k},v_k) \\
v_k &= N(0,R_k)\end{split}
\end{equation}
\sphinxAtStartPar
\sphinxstylestrong{To be overidden by the child class} .
\begin{quote}\begin{description}
\sphinxlineitem{Return zk, Rk}
\sphinxAtStartPar
observation vector and covariance of the observation noise.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{4 DOF AUV EKF Localization using a Constant Velocity Motion Model with Depht, Yaw and Linear Velocity Measurements}
\label{\detokenize{GFLocalization:dof-auv-ekf-localization-using-a-constant-velocity-motion-model-with-depht-yaw-and-linear-velocity-measurements}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{EKF_4DOFAUV_CtVelocityMM_DVLDepthYawOM}.png}
\end{figure}
\index{EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM (class in EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM)@\spxentry{EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM}\spxextra{class in EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_4DOFAUV_CtVelocityMM_DVLDepthYawOM.EKF_4DOFAUV_CtVelocityMM_DVLDepthYawOM}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM.}}\sphinxbfcode{\sphinxupquote{EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM}}}{\sphinxparam{\DUrole{n}{kSteps}}\sphinxparamcomma \sphinxparam{\DUrole{n}{robot}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{GFLocalization:GFLocalization.GFLocalization}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GFLocalization}}}}}, {\hyperref[\detokenize{DRLocalization:DR_4DOFAUV_DVLGyro.DR_4DOFAUV_DVLGyro}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DR\_4DOFAUV\_DVLGyro}}}}}, {\hyperref[\detokenize{EKF:EKF.EKF}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{EKF}}}}}
\index{\_\_init\_\_() (EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM method)@\spxentry{\_\_init\_\_()}\spxextra{EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_4DOFAUV_CtVelocityMM_DVLDepthYawOM.EKF_4DOFAUV_CtVelocityMM_DVLDepthYawOM.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{n}{kSteps}}\sphinxparamcomma \sphinxparam{\DUrole{n}{robot}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Constructor.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x0}} \textendash{} initial state

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{P0}} \textendash{} initial covariance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} Named tuple used to map the state vector, the simulation vector and the observation vector (\sphinxcode{\sphinxupquote{prpy.IndexStruct}})

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kSteps}} \textendash{} simulation time steps

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{robot}} \textendash{} Simulated Robot object

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{args}} \textendash{} arguments to be passed to the parent constructor

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{f() (EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM method)@\spxentry{f()}\spxextra{EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_4DOFAUV_CtVelocityMM_DVLDepthYawOM.EKF_4DOFAUV_CtVelocityMM_DVLDepthYawOM.f}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{f}}}{\sphinxparam{\DUrole{n}{xk\_1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{uk}}}{}
\pysigstopsignatures
\sphinxAtStartPar

Motion model of the EKF to be overwritten by the child class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_1}} \textendash{} previous mean state vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{uk}} \textendash{} input vector

\end{itemize}

\sphinxlineitem{Return xk\_bar, Pk\_bar}
\sphinxAtStartPar
predicted mean state vector and its covariance matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{Jfx() (EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM method)@\spxentry{Jfx()}\spxextra{EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_4DOFAUV_CtVelocityMM_DVLDepthYawOM.EKF_4DOFAUV_CtVelocityMM_DVLDepthYawOM.Jfx}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Jfx}}}{\sphinxparam{\DUrole{n}{xk\_1}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the motion model with respect to the state vector. \sphinxstyleemphasis{Method to be overwritten by the child class}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_1}} \textendash{} Linearization point. By default the linearization point is the previous state vector taken from a class attribute.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{Jfw() (EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM method)@\spxentry{Jfw()}\spxextra{EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_4DOFAUV_CtVelocityMM_DVLDepthYawOM.EKF_4DOFAUV_CtVelocityMM_DVLDepthYawOM.Jfw}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Jfw}}}{\sphinxparam{\DUrole{n}{xk\_1}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the motion model with respect to the noise vector. \sphinxstyleemphasis{Method to be overwritten by the child class}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_1}} \textendash{} Linearization point. By default the linearization point is the previous state vector taken from a class attribute.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{hm() (EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM method)@\spxentry{hm()}\spxextra{EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_4DOFAUV_CtVelocityMM_DVLDepthYawOM.EKF_4DOFAUV_CtVelocityMM_DVLDepthYawOM.hm}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{hm}}}{\sphinxparam{\DUrole{n}{xk\_bar}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Observation model related to the measurements observations of the EKF to be overwritten by the child class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_bar}} \textendash{} mean of the predicted state vector. By default it is taken from the class attribute.

\sphinxlineitem{Returns}
\sphinxAtStartPar
expected observation vector

\end{description}\end{quote}

\end{fulllineitems}

\index{Jhmx() (EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM method)@\spxentry{Jhmx()}\spxextra{EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_4DOFAUV_CtVelocityMM_DVLDepthYawOM.EKF_4DOFAUV_CtVelocityMM_DVLDepthYawOM.Jhmx}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Jhmx}}}{\sphinxparam{\DUrole{n}{xk\_bar}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{Jhmv() (EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM method)@\spxentry{Jhmv()}\spxextra{EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_4DOFAUV_CtVelocityMM_DVLDepthYawOM.EKF_4DOFAUV_CtVelocityMM_DVLDepthYawOM.Jhmv}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Jhmv}}}{\sphinxparam{\DUrole{n}{xk\_bar}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{GetInput() (EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM method)@\spxentry{GetInput()}\spxextra{EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_4DOFAUV_CtVelocityMM_DVLDepthYawOM.EKF_4DOFAUV_CtVelocityMM_DVLDepthYawOM.GetInput}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetInput}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Get the input from the robot. Relates to the motion model as follows:
\begin{equation}\label{equation:GFLocalization:eq-f-GFLocalization}
\begin{split}x_k &= f(x_{k-1},u_k,w_k) \\
w_k &= N(0,Q_k)\end{split}
\end{equation}
\sphinxAtStartPar
\sphinxstylestrong{To be overidden by the child class} .
\begin{quote}\begin{description}
\sphinxlineitem{Return uk, Qk}
\sphinxAtStartPar
input and covariance of the motion model

\end{description}\end{quote}

\end{fulllineitems}

\index{GetMeasurements() (EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM method)@\spxentry{GetMeasurements()}\spxextra{EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM.EKF\_4DOFAUV\_CtVelocityMM\_DVLDepthYawOM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_4DOFAUV_CtVelocityMM_DVLDepthYawOM.EKF_4DOFAUV_CtVelocityMM_DVLDepthYawOM.GetMeasurements}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetMeasurements}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Get the measurements from the robot. Corresponds to the observation model:
\begin{equation}\label{equation:GFLocalization:eq-h}
\begin{split}z_k &= h(x_{k},v_k) \\
v_k &= N(0,R_k)\end{split}
\end{equation}
\sphinxAtStartPar
\sphinxstylestrong{To be overidden by the child class} .
\begin{quote}\begin{description}
\sphinxlineitem{Return zk, Rk}
\sphinxAtStartPar
observation vector and covariance of the observation noise.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{3 DOF Differential Drive Mobile Robot}
\label{\detokenize{GFLocalization:dof-differential-drive-mobile-robot}}

\paragraph{Differential Drive Grid EKF Using an Input displacement Motion Model}
\label{\detokenize{GFLocalization:differential-drive-grid-ekf-using-an-input-displacement-motion-model}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{EKF_3DOFDifferentialDriveInputDisplacement}.png}
\end{figure}
\index{EKF\_3DOFDifferentialDriveInputDisplacement (class in EKF\_3DOFDifferentialDriveInputDisplacement)@\spxentry{EKF\_3DOFDifferentialDriveInputDisplacement}\spxextra{class in EKF\_3DOFDifferentialDriveInputDisplacement}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_3DOFDifferentialDriveInputDisplacement.EKF_3DOFDifferentialDriveInputDisplacement}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{EKF\_3DOFDifferentialDriveInputDisplacement.}}\sphinxbfcode{\sphinxupquote{EKF\_3DOFDifferentialDriveInputDisplacement}}}{\sphinxparam{\DUrole{n}{kSteps}}\sphinxparamcomma \sphinxparam{\DUrole{n}{robot}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{GFLocalization:GFLocalization.GFLocalization}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GFLocalization}}}}}, {\hyperref[\detokenize{DRLocalization:DR_3DOFDifferentialDrive.DR_3DOFDifferentialDrive}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DR\_3DOFDifferentialDrive}}}}}, {\hyperref[\detokenize{EKF:EKF.EKF}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{EKF}}}}}

\sphinxAtStartPar
This class implements an EKF localization filter for a 4 DOF AUV using an input velocity motion model  incorporating
DVL linear velocity mesurements, a gyro angular speed measurement, as well as  depth and yaw measurements.
Inherit from \sphinxcode{\sphinxupquote{PoseCompounding4DOF}} first, to ensure it uses the overridden \(\oplus\) and \(\ominus\) methods.
Then, it inherits from \sphinxcode{\sphinxupquote{GFLocalization}} to implement a localization filter and, finally, it inherits from
\sphinxcode{\sphinxupquote{EKF}} to use the EKF Gaussian filter implementation for the localization.
\index{\_\_init\_\_() (EKF\_3DOFDifferentialDriveInputDisplacement.EKF\_3DOFDifferentialDriveInputDisplacement method)@\spxentry{\_\_init\_\_()}\spxextra{EKF\_3DOFDifferentialDriveInputDisplacement.EKF\_3DOFDifferentialDriveInputDisplacement method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_3DOFDifferentialDriveInputDisplacement.EKF_3DOFDifferentialDriveInputDisplacement.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{n}{kSteps}}\sphinxparamcomma \sphinxparam{\DUrole{n}{robot}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Constructor.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{args}} \textendash{} arguments to be passed to the base class constructor

\end{description}\end{quote}

\end{fulllineitems}

\index{GetInput() (EKF\_3DOFDifferentialDriveInputDisplacement.EKF\_3DOFDifferentialDriveInputDisplacement method)@\spxentry{GetInput()}\spxextra{EKF\_3DOFDifferentialDriveInputDisplacement.EKF\_3DOFDifferentialDriveInputDisplacement method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_3DOFDifferentialDriveInputDisplacement.EKF_3DOFDifferentialDriveInputDisplacement.GetInput}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetInput}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Get the input from the robot. Relates to the motion model as follows:
\begin{equation}\label{equation:GFLocalization:eq-f-GFLocalization}
\begin{split}x_k &= f(x_{k-1},u_k,w_k) \\
w_k &= N(0,Q_k)\end{split}
\end{equation}
\sphinxAtStartPar
\sphinxstylestrong{To be overidden by the child class} .
\begin{quote}\begin{description}
\sphinxlineitem{Return uk, Qk}
\sphinxAtStartPar
input and covariance of the motion model

\end{description}\end{quote}

\end{fulllineitems}

\index{f() (EKF\_3DOFDifferentialDriveInputDisplacement.EKF\_3DOFDifferentialDriveInputDisplacement method)@\spxentry{f()}\spxextra{EKF\_3DOFDifferentialDriveInputDisplacement.EKF\_3DOFDifferentialDriveInputDisplacement method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_3DOFDifferentialDriveInputDisplacement.EKF_3DOFDifferentialDriveInputDisplacement.f}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{f}}}{\sphinxparam{\DUrole{n}{xk\_1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{uk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Non\sphinxhyphen{}linear motion model using as input the DVL linear velocity and the gyro angular speed:
\begin{equation*}
\begin{split}x_k&=f(x_{k-1},u_k,w_k) = x_{k-1} \oplus (u_k + w_k) \Delta t \\
x_{k-1}&=[x_{k_1}^T, y_{k_1}^T, z_{k_1}^T, \psi_{k_1}^T]^T\\
u_k&=[u_k, v_k, w_k, r_k]^T\end{split}
\end{equation*}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_1}} \textendash{} previous mean state vector (\(x_{k-1}=[x_{k-1}^T, y_{k-1}^T, z_{k-1}^T, \psi_{k-1}^T]^T\)) containing the robot position and heading in the N\sphinxhyphen{}Frame

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{uk}} \textendash{} input vector \(u_k=[u_k^T, v_k^T, w_k^T, r_k^T]^T\) containing the DVL linear velocity and the gyro angular speed, both referenced in the B\sphinxhyphen{}Frame

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
current mean state vector containing the current robot position and heading (\(x_k=[x_k^T, y_k^T, z_k^T, \psi_k^T]^T\)) represented in the N\sphinxhyphen{}Frame

\end{description}\end{quote}

\end{fulllineitems}

\index{Jfx() (EKF\_3DOFDifferentialDriveInputDisplacement.EKF\_3DOFDifferentialDriveInputDisplacement method)@\spxentry{Jfx()}\spxextra{EKF\_3DOFDifferentialDriveInputDisplacement.EKF\_3DOFDifferentialDriveInputDisplacement method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_3DOFDifferentialDriveInputDisplacement.EKF_3DOFDifferentialDriveInputDisplacement.Jfx}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Jfx}}}{\sphinxparam{\DUrole{n}{xk\_1}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the motion model with respect to the state vector:
\begin{equation}\label{equation:GFLocalization:eq-Jfx-EKF_3DOFDifferentialDriveInputDisplacement}
\begin{split}J_{fx}=\frac{\partial f(x_{k-1},u_k,w_k)}{\partial x_{k-1}} = \frac{\partial x_{k-1} \oplus (u_k + w_k)}{\partial x_{k-1}} = J_{1\oplus}\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_1}} \textendash{} Linearization point. By default the linearization point is the previous state vector taken from a class attribute.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{Jfw() (EKF\_3DOFDifferentialDriveInputDisplacement.EKF\_3DOFDifferentialDriveInputDisplacement method)@\spxentry{Jfw()}\spxextra{EKF\_3DOFDifferentialDriveInputDisplacement.EKF\_3DOFDifferentialDriveInputDisplacement method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_3DOFDifferentialDriveInputDisplacement.EKF_3DOFDifferentialDriveInputDisplacement.Jfw}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Jfw}}}{\sphinxparam{\DUrole{n}{xk\_1}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the motion model with respect to the motion model noise vector:
\begin{equation}\label{equation:GFLocalization:eq-Jfw-EKF_3DOFDifferentialDriveInputDisplacement}
\begin{split}J_{fx}=\frac{\partial f(x_{k-1},u_k,w_k)}{\partial w_k} = \frac{\partial x_{k-1} \oplus (u_k + w_k)}{\partial w_k} = J_{2\oplus}\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_1}} \textendash{} Linearization point. By default the linearization point is the previous state vector taken from a class attribute.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{hm() (EKF\_3DOFDifferentialDriveInputDisplacement.EKF\_3DOFDifferentialDriveInputDisplacement method)@\spxentry{hm()}\spxextra{EKF\_3DOFDifferentialDriveInputDisplacement.EKF\_3DOFDifferentialDriveInputDisplacement method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_3DOFDifferentialDriveInputDisplacement.EKF_3DOFDifferentialDriveInputDisplacement.hm}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{hm}}}{\sphinxparam{\DUrole{n}{xk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Observation model related to the measurements observations of the EKF to be overwritten by the child class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_bar}} \textendash{} mean of the predicted state vector. By default it is taken from the class attribute.

\sphinxlineitem{Returns}
\sphinxAtStartPar
expected observation vector

\end{description}\end{quote}

\end{fulllineitems}

\index{GetMeasurements() (EKF\_3DOFDifferentialDriveInputDisplacement.EKF\_3DOFDifferentialDriveInputDisplacement method)@\spxentry{GetMeasurements()}\spxextra{EKF\_3DOFDifferentialDriveInputDisplacement.EKF\_3DOFDifferentialDriveInputDisplacement method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_3DOFDifferentialDriveInputDisplacement.EKF_3DOFDifferentialDriveInputDisplacement.GetMeasurements}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetMeasurements}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Gets the measurement vector and the measurement noise covariance matrix from the robot. The measurement vector contains the depth read from the depth sensor and the heading read from the compass sensor.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
observation vector \(z_k\) and observation noise covariance matrix \(R_k\) defined in eq. \sphinxcode{\sphinxupquote{eq\sphinxhyphen{}zk\sphinxhyphen{}EKF\_3DOFDifferentialDriveInputDisplacement}}.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{Differential Drive Grid EKF Using a Constant Velocity Motion Model}
\label{\detokenize{GFLocalization:differential-drive-grid-ekf-using-a-constant-velocity-motion-model}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{EKF_3DOFDifferentialDriveCtVelocity}.png}
\end{figure}
\index{EKF\_3DOFDifferentialDriveCtVelocity (class in EKF\_3DOFDifferentialDriveCtVelocity)@\spxentry{EKF\_3DOFDifferentialDriveCtVelocity}\spxextra{class in EKF\_3DOFDifferentialDriveCtVelocity}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_3DOFDifferentialDriveCtVelocity.EKF_3DOFDifferentialDriveCtVelocity}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{EKF\_3DOFDifferentialDriveCtVelocity.}}\sphinxbfcode{\sphinxupquote{EKF\_3DOFDifferentialDriveCtVelocity}}}{\sphinxparam{\DUrole{n}{kSteps}}\sphinxparamcomma \sphinxparam{\DUrole{n}{robot}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{GFLocalization:GFLocalization.GFLocalization}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GFLocalization}}}}}, {\hyperref[\detokenize{DRLocalization:DR_3DOFDifferentialDrive.DR_3DOFDifferentialDrive}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DR\_3DOFDifferentialDrive}}}}}, {\hyperref[\detokenize{EKF:EKF.EKF}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{EKF}}}}}
\index{\_\_init\_\_() (EKF\_3DOFDifferentialDriveCtVelocity.EKF\_3DOFDifferentialDriveCtVelocity method)@\spxentry{\_\_init\_\_()}\spxextra{EKF\_3DOFDifferentialDriveCtVelocity.EKF\_3DOFDifferentialDriveCtVelocity method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_3DOFDifferentialDriveCtVelocity.EKF_3DOFDifferentialDriveCtVelocity.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{n}{kSteps}}\sphinxparamcomma \sphinxparam{\DUrole{n}{robot}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Constructor.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x0}} \textendash{} initial state

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{P0}} \textendash{} initial covariance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} Named tuple used to map the state vector, the simulation vector and the observation vector (\sphinxcode{\sphinxupquote{prpy.IndexStruct}})

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kSteps}} \textendash{} simulation time steps

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{robot}} \textendash{} Simulated Robot object

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{args}} \textendash{} arguments to be passed to the parent constructor

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{f() (EKF\_3DOFDifferentialDriveCtVelocity.EKF\_3DOFDifferentialDriveCtVelocity method)@\spxentry{f()}\spxextra{EKF\_3DOFDifferentialDriveCtVelocity.EKF\_3DOFDifferentialDriveCtVelocity method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_3DOFDifferentialDriveCtVelocity.EKF_3DOFDifferentialDriveCtVelocity.f}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{f}}}{\sphinxparam{\DUrole{n}{xk\_1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{uk}}}{}
\pysigstopsignatures
\sphinxAtStartPar

Motion model of the EKF to be overwritten by the child class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_1}} \textendash{} previous mean state vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{uk}} \textendash{} input vector

\end{itemize}

\sphinxlineitem{Return xk\_bar, Pk\_bar}
\sphinxAtStartPar
predicted mean state vector and its covariance matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{Jfx() (EKF\_3DOFDifferentialDriveCtVelocity.EKF\_3DOFDifferentialDriveCtVelocity method)@\spxentry{Jfx()}\spxextra{EKF\_3DOFDifferentialDriveCtVelocity.EKF\_3DOFDifferentialDriveCtVelocity method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_3DOFDifferentialDriveCtVelocity.EKF_3DOFDifferentialDriveCtVelocity.Jfx}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Jfx}}}{\sphinxparam{\DUrole{n}{xk\_1}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the motion model with respect to the state vector. \sphinxstyleemphasis{Method to be overwritten by the child class}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_1}} \textendash{} Linearization point. By default the linearization point is the previous state vector taken from a class attribute.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{Jfw() (EKF\_3DOFDifferentialDriveCtVelocity.EKF\_3DOFDifferentialDriveCtVelocity method)@\spxentry{Jfw()}\spxextra{EKF\_3DOFDifferentialDriveCtVelocity.EKF\_3DOFDifferentialDriveCtVelocity method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_3DOFDifferentialDriveCtVelocity.EKF_3DOFDifferentialDriveCtVelocity.Jfw}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Jfw}}}{\sphinxparam{\DUrole{n}{xk\_1}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the motion model with respect to the noise vector. \sphinxstyleemphasis{Method to be overwritten by the child class}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_1}} \textendash{} Linearization point. By default the linearization point is the previous state vector taken from a class attribute.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{hm() (EKF\_3DOFDifferentialDriveCtVelocity.EKF\_3DOFDifferentialDriveCtVelocity method)@\spxentry{hm()}\spxextra{EKF\_3DOFDifferentialDriveCtVelocity.EKF\_3DOFDifferentialDriveCtVelocity method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_3DOFDifferentialDriveCtVelocity.EKF_3DOFDifferentialDriveCtVelocity.hm}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{hm}}}{\sphinxparam{\DUrole{n}{xk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Observation model related to the measurements observations of the EKF to be overwritten by the child class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_bar}} \textendash{} mean of the predicted state vector. By default it is taken from the class attribute.

\sphinxlineitem{Returns}
\sphinxAtStartPar
expected observation vector

\end{description}\end{quote}

\end{fulllineitems}

\index{GetInput() (EKF\_3DOFDifferentialDriveCtVelocity.EKF\_3DOFDifferentialDriveCtVelocity method)@\spxentry{GetInput()}\spxextra{EKF\_3DOFDifferentialDriveCtVelocity.EKF\_3DOFDifferentialDriveCtVelocity method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_3DOFDifferentialDriveCtVelocity.EKF_3DOFDifferentialDriveCtVelocity.GetInput}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetInput}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Get the input from the robot. Relates to the motion model as follows:
\begin{equation}\label{equation:GFLocalization:eq-f-GFLocalization}
\begin{split}x_k &= f(x_{k-1},u_k,w_k) \\
w_k &= N(0,Q_k)\end{split}
\end{equation}
\sphinxAtStartPar
\sphinxstylestrong{To be overidden by the child class} .
\begin{quote}\begin{description}
\sphinxlineitem{Return uk, Qk}
\sphinxAtStartPar
input and covariance of the motion model

\end{description}\end{quote}

\end{fulllineitems}

\index{GetMeasurements() (EKF\_3DOFDifferentialDriveCtVelocity.EKF\_3DOFDifferentialDriveCtVelocity method)@\spxentry{GetMeasurements()}\spxextra{EKF\_3DOFDifferentialDriveCtVelocity.EKF\_3DOFDifferentialDriveCtVelocity method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GFLocalization:EKF_3DOFDifferentialDriveCtVelocity.EKF_3DOFDifferentialDriveCtVelocity.GetMeasurements}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetMeasurements}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Get the measurements from the robot. Corresponds to the observation model:
\begin{equation}\label{equation:GFLocalization:eq-h}
\begin{split}z_k &= h(x_{k},v_k) \\
v_k &= N(0,R_k)\end{split}
\end{equation}
\sphinxAtStartPar
\sphinxstylestrong{To be overidden by the child class} .
\begin{quote}\begin{description}
\sphinxlineitem{Return zk, Rk}
\sphinxAtStartPar
observation vector and covariance of the observation noise.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Feature Map based EKF Localzation}
\label{\detokenize{Localization_index:feature-map-based-ekf-localzation}}
\sphinxstepscope


\subsubsection{Feature Map based EKF LocalIzation}
\label{\detokenize{FEKFMBLocalization:feature-map-based-ekf-localization}}\label{\detokenize{FEKFMBLocalization::doc}}

\subsubsection{Map Feature}
\label{\detokenize{FEKFMBLocalization:map-feature}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{MapFeature}.png}
\end{figure}
\index{MapFeature (class in MapFeature)@\spxentry{MapFeature}\spxextra{class in MapFeature}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MapFeature.MapFeature}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{MapFeature.}}\sphinxbfcode{\sphinxupquote{MapFeature}}}{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
This class provides the functionality required to use Map Features for Robo Localization. It has methods for reading
the feature pose using the robot the sensors ({\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.GetFeatures}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GetFeatures()}}}}}), as well as for computing its:
\begin{itemize}
\item {} 
\sphinxAtStartPar
observation model  ({\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.hf}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hf()}}}}}),

\item {} 
\sphinxAtStartPar
inverse observation model ({\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.g}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{g()}}}}})

\item {} 
\sphinxAtStartPar
all the required Jacobians ({\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.Jhfx}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Jhfx()}}}}}, {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.Jhfv}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Jhfv()}}}}}, {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.Jgx}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Jgx()}}}}} and {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.Jgv}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Jgv()}}}}}).

\end{itemize}

\sphinxAtStartPar
When mapped, a feature may involve 2 different representations:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The observation representation, which is the representation used by the sensors to observe the feature.

\item {} 
\sphinxAtStartPar
The storage representation, which is the representation used to store the feature within the map within the state vector.

\end{itemize}

\sphinxAtStartPar
For instance, a feature may be observed in polar coordinates but stored in Cartesian coordinates. In this case, the
observation representation is the polar coordinates and the storage representation is the Cartesian coordinates. The
class provides method to convert from one representation to the other ({\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.s2o}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{s2o()}}}}} and {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.o2s}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{o2s()}}}}}) and their corresponding
Jacobians ({\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.J_s2o}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{J\_s2o()}}}}} and {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.J_o2s}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{J\_o2s()}}}}}). By default, the observation representation is the same as the storage representation,
but this behaviour may be overriden in child classes.
\index{\_\_init\_\_() (MapFeature.MapFeature method)@\spxentry{\_\_init\_\_()}\spxextra{MapFeature.MapFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MapFeature.MapFeature.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{GetFeatures() (MapFeature.MapFeature method)@\spxentry{GetFeatures()}\spxextra{MapFeature.MapFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MapFeature.MapFeature.GetFeatures}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetFeatures}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Reads the Feature observations from the sensors. For all features within the field of view of the sensor, the
method returns the list of robot\sphinxhyphen{}related poses, the covariance of their corresponding observation noise, the
corresponding observation matrix and the noise Jacobian matrix.
\sphinxstylestrong{This is a pure virtual method that must be overriden in child classes}.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar

\sphinxAtStartPar
vector of features observations in the B\sphinxhyphen{}Frame and the covariance of their corresponding noise.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(z_k=[^Bx_{F_i}^T \cdots ^Bx_{F_j}^T \cdots ^Bx_{F_k}^T]^T\)

\item {} 
\sphinxAtStartPar
\(R_k=block\_diag([R_{F_i} \cdots R_{F_j} \cdots R_{F_k}])\)

\item {} 
\sphinxAtStartPar
\(H_k=block\_diag([H_{F_i} \cdots H_{F_j} \cdots H_{F_k}])\)

\item {} 
\sphinxAtStartPar
\(V_K=I_{z_{nf} \times z_{nf}}\)

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{s2o() (MapFeature.MapFeature method)@\spxentry{s2o()}\spxextra{MapFeature.MapFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MapFeature.MapFeature.s2o}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{s2o}}}{\sphinxparam{\DUrole{n}{v}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Conversion function from the storage representation to the observation representation.
By default, it returns the same vector as the one provided as input, assuming that the observation representation is the same as the storage representation.
In case it is not, this method must be overriden in the child class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{v}} \textendash{} vector in the storage representation

\sphinxlineitem{Returns}
\sphinxAtStartPar
vector in the observation representation

\end{description}\end{quote}

\end{fulllineitems}

\index{o2s() (MapFeature.MapFeature method)@\spxentry{o2s()}\spxextra{MapFeature.MapFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MapFeature.MapFeature.o2s}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{o2s}}}{\sphinxparam{\DUrole{n}{v}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Conversion function from the observation representation to the storage representation. By default, it returns the
same vector as the one provided as input, assuming that the observation representation is the same as the storage representation.
In case it is not, this method must be overriden in child classes.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{v}} \textendash{} vector in the observation representation

\sphinxlineitem{Returns}
\sphinxAtStartPar
vector in the storage representation

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_s2o() (MapFeature.MapFeature method)@\spxentry{J\_s2o()}\spxextra{MapFeature.MapFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MapFeature.MapFeature.J_s2o}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{J\_s2o}}}{\sphinxparam{\DUrole{n}{v}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the conversion function from the storage representation to the observation representation.
By default, it returns the identity matrix, assuming that the observation representation is the same as the storage representation.
In case it is not, this method must be overriden in the derived class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{v}} \textendash{} vector in the storage representation

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian of the conversion function from the storage representation to the observation representation

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_o2s() (MapFeature.MapFeature method)@\spxentry{J\_o2s()}\spxextra{MapFeature.MapFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MapFeature.MapFeature.J_o2s}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{J\_o2s}}}{\sphinxparam{\DUrole{n}{v}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the conversion function from the observation representation to the storage representation.
By default, it returns the identity matrix, assuming that the observation representation is the same as the storage representation.
In case it is not, this method must be overriden in the derived class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{v}} \textendash{} vector in the observation representation

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian of the conversion function from the observation representation to the storage representation

\end{description}\end{quote}

\end{fulllineitems}

\index{hf() (MapFeature.MapFeature method)@\spxentry{hf()}\spxextra{MapFeature.MapFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MapFeature.MapFeature.hf}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{hf}}}{\sphinxparam{\DUrole{n}{xk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This is the direct observation model, implementing the feature observation function for the data
association hypothesis \(H=[H_1~\cdots~H_i~\cdots~H_{n_{zf}}]\) stored in the attibute \sphinxcode{\sphinxupquote{FEKFMBL.FEKFMBL.H}}.
Given the obsevation vector \(z_f=[z_{f_1}^T~\cdots~z_{f_i}^T~\cdots~z_{f_{n_{zf}}}^T]^T\), the state vector
\(x_k=[^Nx_B^T~x_{rest}^T]^T\) and the observation noise \(v_k=[v_{f1_k}^T~\cdots~v_{fi_k}^T~\cdots~v_{fn_{zf_k}}^T]^T\)
the observation equation is given by:
\begin{equation}\label{equation:FEKFMBLocalization:eq-hf}
\begin{split}z_f=h_f(x_k,v_k) \\\end{split}
\end{equation}
\sphinxAtStartPar
which may be expanded as follows:
\begin{equation}\label{equation:FEKFMBLocalization:eq-hf-element-wise}
\begin{split}\begin{bmatrix} z_{f_1} \\ \vdots  \\ z_{f_i} \\ \vdots \\ z_{n_{zf}} \end{bmatrix} = \begin{bmatrix} h_{f_{H_1}}(x_k,v_k) \\ \vdots \\ h_{f_{H_i}}(x_k,v_k) \\ \vdots \\ h_{f_{H_{n_{z_f}}}}(x_k,v_k) \end{bmatrix}
= \begin{bmatrix} s2o(\ominus ^Nx_B \boxplus^Nx_{F_{H_1}})+ v_{f1_k}\\ \vdots \\  s2o(\ominus ^Nx_B \boxplus^Nx_{F_{H_i}})+ v_{fi_k}\\ \vdots \\ s2o(\ominus ^Nx_B \boxplus ^Nx_{F_{H_{n_{zf}}}}) + v_{fn_{zf}}\end{bmatrix}\end{split}
\end{equation}
\sphinxAtStartPar
being {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.hfj}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hfj()}}}}} the observation function (eq. \eqref{equation:FEKFMBLocalization:eq-hfj}) for the data association hypothesis \(H_i \Rightarrow z_{fi} \rightarrow  ^Nx_{F_{H_i}}\), and {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.s2o}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{s2o()}}}}} the conversion
function from the storage representation to the observation one.

\sphinxAtStartPar
The method computes the expected observation \(h_{f}\) for the \(z_{f}\) observation.
To do it, it iterates over each feature observation \(z_{f_i}\) calling the method {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.hfj}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hfj()}}}}}
to compute the expected observation \(h_{f_{H_i}}\) for each feature observation \(z_{f_i}\), collecting all them in the returned vector.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk}} \textendash{} state vector mean \(\hat x_k\).

\sphinxlineitem{Returns}
\sphinxAtStartPar
vector of expected features observations corresponding to the vector of observed features \(z_f\).

\end{description}\end{quote}

\end{fulllineitems}

\index{Jhfx() (MapFeature.MapFeature method)@\spxentry{Jhfx()}\spxextra{MapFeature.MapFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MapFeature.MapFeature.Jhfx}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Jhfx}}}{\sphinxparam{\DUrole{n}{xk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Computes the Jacobian of the feature observation function {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.hf}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hf()}}}}} (eq. \eqref{equation:FEKFMBLocalization:eq-hf}), with respect to the state vector \(\bar{x}_k\):
\begin{equation}\label{equation:FEKFMBLocalization:eq-Jhfx}
\begin{split}J_{hfx}=\frac{\partial h_f(x_k,v_k)}{\partial x_k}=\begin{bmatrix} \frac{\partial h_{f_{H_1}}(x_k,v_k)}{\partial x_k} \\ \vdots \\ \frac{\partial h_{f_{H_i}}(x_k,v_k)}{\partial x_k} \\ \vdots \\ \frac{\partial h_{f_{H_{n_{zf}}}}(x_k,v_k)}{\partial x_k} \end{bmatrix}
=\begin{bmatrix} J_{hfH1x} \\ \vdots \\ J_{hfH2x} \\ \vdots \\ J_{hfHn_{zf}x} \end{bmatrix}\end{split}
\end{equation}
\sphinxAtStartPar
where \(J_{hfjx}\) is the Jacobian of the observation function {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.hfj}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hfj()}}}}} (eq. \eqref{equation:FEKFMBLocalization:eq-Jhfjx}) for the feature observation \(z_{f_i}\).
To do it, given a vector of observations \(z_f=[z_{f_1}~\cdots~z_{f_i}~\cdots~z_{f_{n_{zf}}}]\) this method iterates over each feature observation \(z_{f_i}\) calling the method {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.Jhfjx}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Jhfjx()}}}}} to compute
the Jacobian of the observation function for each feature observation (\(J_{hfjx}\)), collecting all them in the returned Jacobian matrix \(J_{hfx}\).
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk}} \textendash{} state vector mean \(\hat x_k\).

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian of the observation function {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.hf}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hf()}}}}} with respect ro the robot pose \(J_{hfx}=\frac{\partial h_f(\bar{x}_k,v_{f_k})}{\bar{x}_k}\)

\end{description}\end{quote}

\end{fulllineitems}

\index{Jhfv() (MapFeature.MapFeature method)@\spxentry{Jhfv()}\spxextra{MapFeature.MapFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MapFeature.MapFeature.Jhfv}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Jhfv}}}{\sphinxparam{\DUrole{n}{xk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Computes the Jacobian of the observation function {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.hf}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hf()}}}}} with respect to the observation noise \(v_k\).
Normally, the observation noise in the observation B\sphinxhyphen{}Frame is linear (see eq. \eqref{equation:FEKFMBLocalization:eq-hf-element-wise}) so the Jacobian is the identity matrix.
\begin{equation}\label{equation:FEKFMBLocalization:eq-Jhfv}
\begin{split}J_{hfv}&=\frac{\partial h_f(x_k,v_k)}{\partial v_k}\\
&=\begin{bmatrix} \frac{\partial h_{f_{H_1}}(x_k,v_k)}{\partial v_k} \\ \vdots \\ \frac{\partial h_{f_{H_i}}(x_k,v_k)}{\partial v_k} \\ \vdots \\ \frac{\partial h_{f_{H_{n_{zf}}}}(x_k,v_k)}{\partial v_k} \end{bmatrix}
=\begin{bmatrix}
    \frac{\partial h_{f_{H_1}}(x_k,v_k)}{\partial v_{f1_k}} &  \cdots & 0 & 0 & 0  & \cdots & 0 \\
    \vdots & \ddots & \vdots & \vdots & \vdots & \ddots & \vdots \\
    0 & \cdots &  0 & \frac{\partial h_{f_{H_1}}(x_k,v_k)}{\partial v_{fi_k}} &  0 & \cdots & 0 \\
    \vdots & \ddots & \vdots & \vdots & \vdots & \ddots & \vdots \\
    0 & \cdots & 0 & 0 & 0 & \frac{\partial h_{f_{H_1}}(x_k,v_k)}{\partial v_{fn_{zf_k}}}  \\
\end{bmatrix}= I_{n_{zf}\times n_{zf}}\end{split}
\end{equation}
\sphinxAtStartPar
If it is not the case, this method must be overriden.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk}} \textendash{} state vector mean \(\hat x_k\).

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian of the observation function {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.hf}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hf()}}}}} with respect ro the observation noise \(v_k\) \(J_{hfv}=I_{n_{zf}\times n_{zf}}\)

\end{description}\end{quote}

\end{fulllineitems}

\index{hfj() (MapFeature.MapFeature method)@\spxentry{hfj()}\spxextra{MapFeature.MapFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MapFeature.MapFeature.hfj}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{hfj}}}{\sphinxparam{\DUrole{n}{xk\_bar}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Fj}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This is the direct observation model for a single feature observation  \(z_{f_i}\) , so it implements its related
observation function (see eq. \eqref{equation:FEKFMBLocalization:eq-hfj}). For a single feature observation \(z_{f_i}\) of the feature \(^Nx_{F_{H_i}}\) the method computes its
expected observation from the current robot pose \(^Nx_B\).
This function uses a generic implementation through the following equation:
\begin{equation}\label{equation:FEKFMBLocalization:eq-hfj}
\begin{split}z_{f_i}=h_{f_{H_i}}(x_k,v_k)=s2o(\ominus ^Nx_B \boxplus ^Nx_{F_{H_i}}) + v_{fi_k}\end{split}
\end{equation}
\sphinxAtStartPar
Wwere \(^Nx_B\) is the robot pose included within the state vector (\(x_k=[^Nx_B^T~x_{rest}^T]^T\))  and {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.s2o}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{s2o()}}}}} is a conversion
function from the store representation to the observation representation.

\sphinxAtStartPar
The method is called by {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.hf}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hf()}}}}} to compute the expected observation for each feature
observation contained in the observation vector \(z_f=[z_{f_1}^T~\cdots~z_{1_i}^T~\cdots~z_{f_{n_zf}}^T]^T\).
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_bar}} \textendash{} mean of the predicted state vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Fj}} \textendash{} map index of the observed feature: \(^Nx_{F_j}=self.M[Fj]\)

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
expected observation of the feature \(^Nx_{F_j}\)

\end{description}\end{quote}

\end{fulllineitems}

\index{Jhfjx() (MapFeature.MapFeature method)@\spxentry{Jhfjx()}\spxextra{MapFeature.MapFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MapFeature.MapFeature.Jhfjx}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Jhfjx}}}{\sphinxparam{\DUrole{n}{xk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Fj}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the single feature direct  observation model {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.hfj}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hfj()}}}}} (eq. \eqref{equation:FEKFMBLocalization:eq-hfj})  with respect to the state vector \(\bar{x}_k\):
\begin{equation}\label{equation:FEKFMBLocalization:eq-Jhfjx}
\begin{split}x_k&=[^Nx_B^T~x_{rest}^T]^T\\
^Nx_B&= F \cdot x_k ; F=\begin{bmatrix} I_{p\times p} & 0_{p\times np} \end{bmatrix}\\
J_{hfjx}&=\frac{\partial h_{f_{zfi}}(\bar{x}_k, ^Nx_{F_j},v_k)}{\partial {x}_k}=
\frac{\partial s2o(\ominus F \cdot x_k \boxplus ^Nx_{F_j})+v_{fi_k}}{\partial {x}_k}\\&=
 J_{s2o}(\ominus ^Nx_B \boxplus^Nx_{F_{H_i}}) J_{1\boxplus}(\ominus ^Nx_B,^Nx_{F_{H_i}} ) J_{\ominus}(^Nx_B ) F\end{split}
\end{equation}
\sphinxAtStartPar
where \(p\) is the dimension of the robot pose \(^Nx_B\) and \(np\) is the dimension of the rest of the state vector \(x_{rest}\).
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk}} \textendash{} state vector mean

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Fj}} \textendash{} map index of the observed feature

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian matrix defined in eq. \eqref{equation:FEKFMBLocalization:eq-Jhfjx}

\end{description}\end{quote}

\end{fulllineitems}

\index{g() (MapFeature.MapFeature method)@\spxentry{g()}\spxextra{MapFeature.MapFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MapFeature.MapFeature.g}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{g}}}{\sphinxparam{\DUrole{n}{xk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{BxFj}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This method provides a generic implementation of the inverse observation model. It computes the feature pose in the N\sphinxhyphen{}Frame \(^Nx_{F_j}\) by compounding the robot pose \(^Nx_B\), from where the observation was taken, with the  B\sphinxhyphen{}Frame referenced feature
observation \(Bx_{F_j}\):
\begin{equation}\label{equation:FEKFMBLocalization:eq-g}
\begin{split}^Nx_{F_j} = ^Nx_B \boxplus o2s(^Bx_{F_j} +v_k)\end{split}
\end{equation}
\sphinxAtStartPar
In this case, {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.o2s}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{o2s()}}}}} is the conversion function converting from the observation space to the representation one.
It is worth noting that the robot pose \(^Nx_B\) is included within the state vector \(x_k\) but might not be the whole state vector.
For instance, in some cases the state vector may include as well the robot velocity \(x_k=[^Nx_B^T~^B\nu_k^T]^T\).
Note that the {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.g}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{g()}}}}} works with a single feature observation, instead than with a vector of feature observations.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk}} \textendash{} mean state vector containing the robot pose \(^Nx_B\) from where the observation was taken

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{BxFj}} \textendash{} feature observation in the B\sphinxhyphen{}Frame \(^Bx_{F_j}\)

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
mean feature pose in the N\sphinxhyphen{}Frame \(^Nx_{F_j}\)

\end{description}\end{quote}

\end{fulllineitems}

\index{Jgx() (MapFeature.MapFeature method)@\spxentry{Jgx()}\spxextra{MapFeature.MapFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MapFeature.MapFeature.Jgx}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Jgx}}}{\sphinxparam{\DUrole{n}{xk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{BxFj}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the inverse observation model {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.g}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{g()}}}}}, with respect to the state vector \(x_k\).
According to the generic implementation of the inverse observation model {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.g}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{g()}}}}} eq. \eqref{equation:FEKFMBLocalization:eq-g}, the Jacobian is computed as follows:
\begin{equation}\label{equation:FEKFMBLocalization:eq-Jgx}
\begin{split}J_{gx}=\frac{\partial g(^Nx_B,^Bx_{F_j})}{x_k}=\begin{bmatrix} J_{1\boxplus}(^Nx_B,o2s(^Bx_{F_j})) & 0  \end{bmatrix}\end{split}
\end{equation}
\sphinxAtStartPar
The zero submatrix, if present, corresponds to the derivate with respect to the non\sphinxhyphen{}positional elements of the
state vector, for instance the robot velocity \(^B\nu_k\), in case this was included within the state vector.
If the state vector only containes the pose, then the 0 submatix vanishes.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_bar}} \textendash{} predicted state vector

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian of the inverse observation model {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.g}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{g()}}}}} with respect to the state vector (eq. \eqref{equation:FEKFMBLocalization:eq-Jgx})

\end{description}\end{quote}

\end{fulllineitems}

\index{Jgv() (MapFeature.MapFeature method)@\spxentry{Jgv()}\spxextra{MapFeature.MapFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MapFeature.MapFeature.Jgv}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Jgv}}}{\sphinxparam{\DUrole{n}{xk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{BxFj}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the inverse observation model {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.g}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{g()}}}}}, with respect to the observation noise \(v_k\).
According to the generic implementation of the inverse observation model {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.g}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{g()}}}}} eq. \eqref{equation:FEKFMBLocalization:eq-g}, the Jacobian is computed as follows:
\begin{equation}\label{equation:FEKFMBLocalization:eq-Jgv}
\begin{split}J_{gv}=\frac{\partial g(^Nx_k,^Bx_{F_j}),v_k}{v_k}=J_{2\boxplus}(^Nx_B,o2s(^Bx_{F_j})) J_{o2s}(^Bx_{F_j})\end{split}
\end{equation}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk}} \textendash{} state vector containing the robot pose \(^Nx_B\) from where the observation was taken

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{BxFj}} \textendash{} feature observation in the B\sphinxhyphen{}Frame \(^Bx_{F_j}\)

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian of the inverse observation model {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.g}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{g()}}}}} with respect to the observation noise \(J_{gv}\) (see eq. \eqref{equation:FEKFMBLocalization:eq-Jgv}).

\end{description}\end{quote}

\end{fulllineitems}

\index{GetRobotPose() (MapFeature.MapFeature method)@\spxentry{GetRobotPose()}\spxextra{MapFeature.MapFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MapFeature.MapFeature.GetRobotPose}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetRobotPose}}}{\sphinxparam{\DUrole{n}{xk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Extracts the robot pose from the state vector.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk}} \textendash{} mean of the state vector:math:\sphinxtitleref{x\_k}

\sphinxlineitem{Returns}
\sphinxAtStartPar
mean robot pose \(x_{B_k}\)

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{Cartesian Map Feature}
\label{\detokenize{FEKFMBLocalization:cartesian-map-feature}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{Cartesian2DMapFeature}.png}
\end{figure}
\index{Cartesian2DMapFeature (class in MapFeature)@\spxentry{Cartesian2DMapFeature}\spxextra{class in MapFeature}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MapFeature.Cartesian2DMapFeature}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{MapFeature.}}\sphinxbfcode{\sphinxupquote{Cartesian2DMapFeature}}}{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MapFeature}}}}}

\sphinxAtStartPar
This class inherits from the {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MapFeature}}}}} and implements a 2D Cartesian feature model for the MBL problem. The Cartesian coordinates are used for both,
observing the feature and for its storage within the map. This class overrides the {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.Cartesian2DMapFeature.GetFeatures}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GetFeatures()}}}}} method to read
the 2D Cartesian Features from the robot.
\index{GetFeatures() (MapFeature.Cartesian2DMapFeature method)@\spxentry{GetFeatures()}\spxextra{MapFeature.Cartesian2DMapFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MapFeature.Cartesian2DMapFeature.GetFeatures}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetFeatures}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Reads the Features observations from the sensors. For all features within the field of view of the sensor, the
method returns the list of robot\sphinxhyphen{}related poses and the covariance of their corresponding observation noise in \sphinxstylestrong{2D Cartesian coordinates}.
\begin{quote}\begin{description}
\sphinxlineitem{Return zk, Rk}
\sphinxAtStartPar
list of Cartesian features observations in the B\sphinxhyphen{}Frame and the covariance of their corresponding observation noise:
* \(z_k=[^Bx_{F_i}^T \cdots ^Bx_{F_j}^T \cdots ^Bx_{F_k}^T]^T\)
* \(R_k=block\_diag([R_{F_i} \cdots R_{F_j} \cdots R_{F_k}])\)

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{Cartesian Map Feature Observed in Polar Coordinates}
\label{\detokenize{FEKFMBLocalization:cartesian-map-feature-observed-in-polar-coordinates}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{Cartesian2DStoredPolarObservedMapFeature}.png}
\end{figure}
\index{Cartesian2DStoredPolarObservedMapFeature (class in MapFeature)@\spxentry{Cartesian2DStoredPolarObservedMapFeature}\spxextra{class in MapFeature}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MapFeature.Cartesian2DStoredPolarObservedMapFeature}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{MapFeature.}}\sphinxbfcode{\sphinxupquote{Cartesian2DStoredPolarObservedMapFeature}}}{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.Cartesian2DMapFeature}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Cartesian2DMapFeature}}}}}

\sphinxAtStartPar
This class implements the {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MapFeature}}}}} interface for landmarks observed in polar coordinates and stored in Cartesian coordinates.
It inherits from {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.Cartesian2DMapFeature}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Cartesian2DMapFeature}}}}} which provides the {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.Cartesian2DMapFeature.GetFeatures}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Cartesian2DMapFeature.GetFeatures()}}}}} in charge of reading the 2D
Cartesian Features from the robot and overrides the {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.Cartesian2DStoredPolarObservedMapFeature.o2s}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{o2s()}}}}} and {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.Cartesian2DStoredPolarObservedMapFeature.s2o}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{s2o()}}}}} methods to allow the conversion between the observation and storage representations.
\index{GetFeatures() (MapFeature.Cartesian2DStoredPolarObservedMapFeature method)@\spxentry{GetFeatures()}\spxextra{MapFeature.Cartesian2DStoredPolarObservedMapFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MapFeature.Cartesian2DStoredPolarObservedMapFeature.GetFeatures}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetFeatures}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Reads the Features observations from the sensors. For all features within the field of view of the sensor, the
method returns the list of robot\sphinxhyphen{}related poses and the covariance of their corresponding observation noise in \sphinxstylestrong{2D Cartesian coordinates}.
\begin{quote}\begin{description}
\sphinxlineitem{Return zk, Rk}
\sphinxAtStartPar
list of features observations in the B\sphinxhyphen{}Frame and the covariance of their corresponding observation noise:
* \(z_k=[^Bx_{F_i}^T \cdots ^Bx_{F_j}^T \cdots ^Bx_{F_k}^T]^T\)
* \(R_k=block\_diag([R_{F_i} \cdots R_{F_j} \cdots R_{F_k}])\)

\end{description}\end{quote}

\end{fulllineitems}

\index{o2s() (MapFeature.Cartesian2DStoredPolarObservedMapFeature method)@\spxentry{o2s()}\spxextra{MapFeature.Cartesian2DStoredPolarObservedMapFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MapFeature.Cartesian2DStoredPolarObservedMapFeature.o2s}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{o2s}}}{\sphinxparam{\DUrole{n}{p}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Converts the feature from the observation frame to the sensor frame.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{p}} \textendash{} feature in the observation frame

\sphinxlineitem{Returns}
\sphinxAtStartPar
feature in the sensor frame

\end{description}\end{quote}

\end{fulllineitems}

\index{s2o() (MapFeature.Cartesian2DStoredPolarObservedMapFeature method)@\spxentry{s2o()}\spxextra{MapFeature.Cartesian2DStoredPolarObservedMapFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MapFeature.Cartesian2DStoredPolarObservedMapFeature.s2o}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{s2o}}}{\sphinxparam{\DUrole{n}{c}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Converts the feature from the sensor frame to the observation frame.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} feature in the sensor frame

\sphinxlineitem{Returns}
\sphinxAtStartPar
feature in the observation frame

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_o2s() (MapFeature.Cartesian2DStoredPolarObservedMapFeature method)@\spxentry{J\_o2s()}\spxextra{MapFeature.Cartesian2DStoredPolarObservedMapFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MapFeature.Cartesian2DStoredPolarObservedMapFeature.J_o2s}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{J\_o2s}}}{\sphinxparam{\DUrole{n}{p}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.Cartesian2DStoredPolarObservedMapFeature.o2s}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{o2s()}}}}} function.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{p}} \textendash{} feature in the observation frame

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian of the {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.Cartesian2DStoredPolarObservedMapFeature.o2s}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{o2s()}}}}} function

\end{description}\end{quote}

\end{fulllineitems}

\index{J\_s2o() (MapFeature.Cartesian2DStoredPolarObservedMapFeature method)@\spxentry{J\_s2o()}\spxextra{MapFeature.Cartesian2DStoredPolarObservedMapFeature method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MapFeature.Cartesian2DStoredPolarObservedMapFeature.J_s2o}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{J\_s2o}}}{\sphinxparam{\DUrole{n}{c}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Jacobian of the {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.Cartesian2DStoredPolarObservedMapFeature.s2o}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{s2o()}}}}} function.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} feature in the sensor frame

\sphinxlineitem{Returns}
\sphinxAtStartPar
Jacobian of the {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.Cartesian2DStoredPolarObservedMapFeature.s2o}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{s2o()}}}}} function

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{Feature Map based EKF Localization}
\label{\detokenize{FEKFMBLocalization:id1}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{FEKFMBL}.png}
\end{figure}
\index{FEKFMBL (class in FEKFMBL)@\spxentry{FEKFMBL}\spxextra{class in FEKFMBL}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{FEKFMBL.}}\sphinxbfcode{\sphinxupquote{FEKFMBL}}}{\sphinxparam{\DUrole{n}{M}}\sphinxparamcomma \sphinxparam{\DUrole{n}{alpha}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{GFLocalization:GFLocalization.GFLocalization}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GFLocalization}}}}}, {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MapFeature}}}}}

\sphinxAtStartPar
Feature Extended Kalman Filter Map based Localization class. Inherits from {\hyperref[\detokenize{GFLocalization:GFLocalization.GFLocalization}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GFLocalization.GFLocalization}}}}} and {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MapFeature.MapFeature}}}}}.
The first one provides the basic functionality of a localization algorithm, while the second one provides the basic functionality required to use features.
{\hyperref[\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{FEKFMBL.FEKFMBL}}}}} extends those classes by adding functionality to use a map based on features.
\index{\_\_init\_\_() (FEKFMBL.FEKFMBL method)@\spxentry{\_\_init\_\_()}\spxextra{FEKFMBL.FEKFMBL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{n}{M}}\sphinxparamcomma \sphinxparam{\DUrole{n}{alpha}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Constructor of the FEKFMBL class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xBpose\_dim}} \textendash{} dimensionality of the robot pose within the state vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xB\_dim}} \textendash{} dimensionality of the state vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xF\_dim}} \textendash{} dimentsionality of a feature

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{zfi\_dim}} \textendash{} dimensionality of a single feature observation

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{M}} \textendash{} Feature Based Map \(M =[^Nx_{F_1}^T~...~^Nx_{F_{n_f}}^T]^T\)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{alpha}} \textendash{} Chi2 tail probability. Confidence interaval of the individual compatibility test

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{args}} \textendash{} arguments to be passed to the EKFLocalization constructor

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{h() (FEKFMBL.FEKFMBL method)@\spxentry{h()}\spxextra{FEKFMBL.FEKFMBL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.h}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{h}}}{\sphinxparam{\DUrole{n}{xk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Observation model for the joint measurements and feature observations:
\begin{equation}\label{equation:FEKFMBLocalization:eq-mblh}
\begin{split}z_k = h(x_k,v_k) \Rightarrow \begin{bmatrix} z_m \\ z_f \end{bmatrix} = \begin{bmatrix} h_m(x_k,v_m) \\ h_f(x_k,v_f) \end{bmatrix} ~;~ v_k=[v_m^T ~v_f^T]^T\end{split}
\end{equation}
\sphinxAtStartPar
This method calls {\hyperref[\detokenize{EKF:EKF.EKF.hm}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{EKF.EKF.hm()}}}}} and {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.MapFeature.hf}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MapFeature.MapFeature.hf()}}}}}
to obtain the expected sensor measurements and the expected feature observations respectively. The method returns an stacked vector of expected measurements and feature observations.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk}} \textendash{} mean state vector used as linearization point

\sphinxlineitem{Returns}
\sphinxAtStartPar
Joint stacked vector of the expected mesurement and feature observations

\end{description}\end{quote}

\end{fulllineitems}

\index{SquaredMahalanobisDistance() (FEKFMBL.FEKFMBL method)@\spxentry{SquaredMahalanobisDistance()}\spxextra{FEKFMBL.FEKFMBL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.SquaredMahalanobisDistance}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{SquaredMahalanobisDistance}}}{\sphinxparam{\DUrole{n}{hfj}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Pfj}}\sphinxparamcomma \sphinxparam{\DUrole{n}{zfi}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Rfi}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Computes the squared Mahalanobis distance between the expected feature observation \(hf_j\) and the feature observation \(z_{f_i}\).
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hfj}} \textendash{} expected feature observation

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Pfj}} \textendash{} expected feature observation covariance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{zfi}} \textendash{} feature observation

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Rfi}} \textendash{} feature observation covariance

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Squared Mahalanobis distance between the expected feature observation \(hf_j\) and the feature observation \(z_{f_i}\)

\end{description}\end{quote}

\end{fulllineitems}

\index{IndividualCompatibility() (FEKFMBL.FEKFMBL method)@\spxentry{IndividualCompatibility()}\spxextra{FEKFMBL.FEKFMBL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.IndividualCompatibility}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{IndividualCompatibility}}}{\sphinxparam{\DUrole{n}{D2\_ij}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dof}}\sphinxparamcomma \sphinxparam{\DUrole{n}{alpha}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Computes the individual compatibility test for the squared Mahalanobis distance \(D^2_{ij}\). The test is performed using the Chi\sphinxhyphen{}Square distribution with \(dof\) degrees of freedom and a significance level \(\alpha\).
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{D2\_ij}} \textendash{} squared Mahalanobis distance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dof}} \textendash{} number of degrees of freedom

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{alpha}} \textendash{} confidence level

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
bolean value indicating if the Mahalanobis distance is smaller than the threshold defined by the confidence level

\end{description}\end{quote}

\end{fulllineitems}

\index{ICNN() (FEKFMBL.FEKFMBL method)@\spxentry{ICNN()}\spxextra{FEKFMBL.FEKFMBL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.ICNN}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ICNN}}}{\sphinxparam{\DUrole{n}{hf}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Phf}}\sphinxparamcomma \sphinxparam{\DUrole{n}{zf}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Rf}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dim}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Individual Compatibility Nearest Neighbor (ICNN) data association algorithm. Given a set of expected feature
observations \(h_f\) and a set of feature observations \(z_f\), the algorithm returns a pairing hypothesis
\(H\) that associates each feature observation \(z_{f_i}\) with the expected feature observation
\(h_{f_j}\) that minimizes the Mahalanobis distance \(D^2_{ij}\).
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hf}} \textendash{} vector of expected feature observations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Phf}} \textendash{} Covariance matrix of the expected feature observations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{zf}} \textendash{} vector of feature observations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Rf}} \textendash{} Covariance matrix of the feature observations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dim}} \textendash{} feature dimensionality

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
The vector of asociation hypothesiss

\end{description}\end{quote}

\end{fulllineitems}

\index{DataAssociation() (FEKFMBL.FEKFMBL method)@\spxentry{DataAssociation()}\spxextra{FEKFMBL.FEKFMBL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.DataAssociation}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{DataAssociation}}}{\sphinxparam{\DUrole{n}{xk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Pk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{zf}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Rf}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Data association algorithm. Given state vector (\(x_k\) and \(P_k\)) including the robot pose and a set of feature observations
\(z_f\) and its covariance matrices \(R_f\),  the algorithm  computes the expected feature
observations \(h_f\) and its covariance matrices \(P_f\). Then it calls an association algorithms like
{\hyperref[\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.ICNN}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ICNN()}}}}} (JCBB, etc.) to build a pairing hypothesis associating the observed features \(z_f\)
with the expected features observations \(h_f\).

\sphinxAtStartPar
The vector of association hypothesis \(H\) is stored in the \sphinxcode{\sphinxupquote{H}} attribute and its dimension is the
number of observed features within \(z_f\). Given the \(j^{th}\) feature observation \(z_{f_j}\), \sphinxstyleemphasis{self.H{[}j{]}=i}
means that \(z_{f_j}\) has been associated with the \(i^{th}\) feature . If \sphinxstyleemphasis{self.H{[}j{]}=None} means that \(z_{f_j}\)
has not been associated either because it is a new observed feature or because it is an outlier.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk}} \textendash{} mean state vector including the robot pose

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Pk}} \textendash{} covariance matrix of the state vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{zf}} \textendash{} vector of feature observations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Rf}} \textendash{} Covariance matrix of the feature observations

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
The vector of asociation hypothesiss

\end{description}\end{quote}

\end{fulllineitems}

\index{Localize() (FEKFMBL.FEKFMBL method)@\spxentry{Localize()}\spxextra{FEKFMBL.FEKFMBL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.Localize}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Localize}}}{\sphinxparam{\DUrole{n}{xk\_1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Pk\_1}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Localization iteration. Reads the input of the motion model, performs the prediction step ({\hyperref[\detokenize{EKF:EKF.EKF.Prediction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{EKF.EKF.Prediction()}}}}}), reads the measurements
and the features, solves the data association calling {\hyperref[\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.DataAssociation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DataAssociation()}}}}} and the performs the update step ({\hyperref[\detokenize{EKF:EKF.EKF.Update}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{EKF.EKF.Update()}}}}}) and logs the results.
The method also plots the uncertainty ellipse ({\hyperref[\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.PlotUncertainty}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{PlotUncertainty()}}}}}) of the robot pose, the feature observations and the expected feature observations.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk\_1}} \textendash{} previous state vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Pk\_1}} \textendash{} previous covariance matrix

\end{itemize}

\sphinxlineitem{Return xk, Pk}
\sphinxAtStartPar
updated state vector and covariance matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{StackMeasurementsAndFeatures() (FEKFMBL.FEKFMBL method)@\spxentry{StackMeasurementsAndFeatures()}\spxextra{FEKFMBL.FEKFMBL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.StackMeasurementsAndFeatures}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{StackMeasurementsAndFeatures}}}{\sphinxparam{\DUrole{n}{zm}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Rm}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Hm}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Vm}}\sphinxparamcomma \sphinxparam{\DUrole{n}{zf}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Rf}}\sphinxparamcomma \sphinxparam{\DUrole{n}{H}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Given the vector of  measurements observations \(z_m\) together with their covariance matrix \(R_m\),
the vector of feature observations \(z_f\) together with their covariance matrix \(R_f\), The measurement observation matrix \(H_m\), the
measurement observation noise matrix \(V_m\) and the vector of feature associations \(H\), this method
returns the joint observation vector \(z_k\), its related covariance matrix \(R_k\), the stacked
Observation matrix \(H_k\), the stacked noise observation matrix \(V_k\), the vector of non\sphinxhyphen{}paired features
\(z_{np}\) and its noise covariance matrix \(R_{np}\).
It is assumed that the measurements and the features observations are independent, therefore the covariance matrix
of the joint observation vector is a block diagonal matrix.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{zm}} \textendash{} measurement observations vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Rm}} \textendash{} covariance matrix of the measurement observations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Hm}} \textendash{} measurement observation matrix

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Vm}} \textendash{} measurement observation noise matrix

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{zf}} \textendash{} feature observations vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Rf}} \textendash{} covariance matrix of the feature observations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{H}} \textendash{} features associations vector

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
vector of joint measurement and feature observations \(z_k\) and its covariance matrix \(R_k\)

\end{description}\end{quote}

\end{fulllineitems}

\index{SplitFeatures() (FEKFMBL.FEKFMBL method)@\spxentry{SplitFeatures()}\spxextra{FEKFMBL.FEKFMBL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.SplitFeatures}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{SplitFeatures}}}{\sphinxparam{\DUrole{n}{zf}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Rf}}\sphinxparamcomma \sphinxparam{\DUrole{n}{H}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Given the vector of feature observations \(z_f\) and their covariance matrix \(R_f\), and the vector of
feature associations \(H\), this function returns the vector of paired feature observations \(z_p\) together with
its covariance matrix \(R_p\), and the vector of non\sphinxhyphen{}paired feature observations \(z_{np}\) together with its covariance matrix \(R_{np}\).
The paired observations will be used to update the filter, while the non\sphinxhyphen{}paired ones will be considered as outliers.
In the case of SLAM, they become new feature candidates.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{zf}} \textendash{} vector of feature observations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Rf}} \textendash{} covariance matrix of feature observations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{H}} \textendash{} hypothesis of feature associations

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
vector of paired feature observations \(z_p\), covariance matrix of paired feature observations \(R_p\), vector of non\sphinxhyphen{}paired feature observations \(z_{np}\), covariance matrix of non\sphinxhyphen{}paired feature observations \(R_{np}\).

\end{description}\end{quote}

\end{fulllineitems}

\index{PlotFeatureObservationUncertainty() (FEKFMBL.FEKFMBL method)@\spxentry{PlotFeatureObservationUncertainty()}\spxextra{FEKFMBL.FEKFMBL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.PlotFeatureObservationUncertainty}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{PlotFeatureObservationUncertainty}}}{\sphinxparam{\DUrole{n}{zf}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Rf}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Plots the uncertainty ellipse of the feature observations. This method is called by {\hyperref[\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.PlotUncertainty}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{FEKFMBL.PlotUncertainty()}}}}}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{zf}} \textendash{} vector of feature observations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Rf}} \textendash{} covariance matrix of the feature observations

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{PlotExpectedFeaturesObservationsUncertainty() (FEKFMBL.FEKFMBL method)@\spxentry{PlotExpectedFeaturesObservationsUncertainty()}\spxextra{FEKFMBL.FEKFMBL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.PlotExpectedFeaturesObservationsUncertainty}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{PlotExpectedFeaturesObservationsUncertainty}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
For all features in the map, this method plots the uncertainty ellipse of the expected feature observations. This method is called by {\hyperref[\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.PlotUncertainty}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{FEKFMBL.PlotUncertainty()}}}}}.

\end{fulllineitems}

\index{PlotSampleObservationSpace() (FEKFMBL.FEKFMBL method)@\spxentry{PlotSampleObservationSpace()}\spxextra{FEKFMBL.FEKFMBL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.PlotSampleObservationSpace}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{PlotSampleObservationSpace}}}{\sphinxparam{\DUrole{n}{NxB}}\sphinxparamcomma \sphinxparam{\DUrole{n}{BxFj}}\sphinxparamcomma \sphinxparam{\DUrole{n}{BPFj}}\sphinxparamcomma \sphinxparam{\DUrole{n}{n}}\sphinxparamcomma \sphinxparam{\DUrole{n}{color}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}r.\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Plots n samples from a Gaussian distribution with mean \(x\) and covariance \(P\). This method is called by {\hyperref[\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.PlotUncertainty}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{FEKFMBL.PlotUncertainty()}}}}}.
This is a method for testing. It can be used to compare the uncertainty ellipse with the samples.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} mean of the Gaussian distribution

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{P}} \textendash{} covariance of the Gaussian distribution

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n}} \textendash{} number of samples

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{color}} \textendash{} color of the samples

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{PlotSample() (FEKFMBL.FEKFMBL method)@\spxentry{PlotSample()}\spxextra{FEKFMBL.FEKFMBL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.PlotSample}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{PlotSample}}}{\sphinxparam{\DUrole{n}{x}}\sphinxparamcomma \sphinxparam{\DUrole{n}{P}}\sphinxparamcomma \sphinxparam{\DUrole{n}{n}}\sphinxparamcomma \sphinxparam{\DUrole{n}{color}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}r.\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Plots n samples from a Gaussian distribution with mean \(x\) and covariance \(P\). This method is called by {\hyperref[\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.PlotUncertainty}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{FEKFMBL.PlotUncertainty()}}}}}.
This is a method for testing. It can be used to compare the uncertainty ellipse with the samples.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} mean of the Gaussian distribution

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{P}} \textendash{} covariance of the Gaussian distribution

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n}} \textendash{} number of samples

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{color}} \textendash{} color of the samples

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{PlotRobotUncertainty() (FEKFMBL.FEKFMBL method)@\spxentry{PlotRobotUncertainty()}\spxextra{FEKFMBL.FEKFMBL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.PlotRobotUncertainty}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{PlotRobotUncertainty}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Plots the robot trajectory and its uncertainty ellipse. This method is called by {\hyperref[\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.PlotUncertainty}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{FEKFMBL.PlotUncertainty()}}}}}.

\end{fulllineitems}

\index{PlotUncertainty() (FEKFMBL.FEKFMBL method)@\spxentry{PlotUncertainty()}\spxextra{FEKFMBL.FEKFMBL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.PlotUncertainty}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{PlotUncertainty}}}{\sphinxparam{\DUrole{n}{zf}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Rf}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Plots the uncertainty ellipses of the robot pose ({\hyperref[\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.PlotRobotUncertainty}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{PlotRobotUncertainty()}}}}}), the feature observations
({\hyperref[\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.PlotFeatureObservationUncertainty}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{PlotFeatureObservationUncertainty()}}}}}) and the expected feature observations ({\hyperref[\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.PlotExpectedFeaturesObservationsUncertainty}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{PlotExpectedFeaturesObservationsUncertainty()}}}}}).
This method is called by {\hyperref[\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.Localize}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{FEKFMBL.Localize()}}}}} at the end of a localization iteration in order to update
the online  visualization.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{zf}} \textendash{} vector of feature observations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Rf}} \textendash{} covariance matrix of the feature observations

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{GetRobotState() (FEKFMBL.FEKFMBL method)@\spxentry{GetRobotState()}\spxextra{FEKFMBL.FEKFMBL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.GetRobotState}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetRobotState}}}{\sphinxparam{\DUrole{n}{xk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Returns the robot state from the state vector.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk}} \textendash{} mean of the state vector:math:\sphinxtitleref{x\_k}

\sphinxlineitem{Returns}
\sphinxAtStartPar
mean robot state \(x_{B_k}\)

\end{description}\end{quote}

\end{fulllineitems}

\index{SetRobotState() (FEKFMBL.FEKFMBL method)@\spxentry{SetRobotState()}\spxextra{FEKFMBL.FEKFMBL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.SetRobotState}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{SetRobotState}}}{\sphinxparam{\DUrole{n}{xk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{xB}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Updates the robot state within the state vector.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk}} \textendash{} mean of the state vector:math:\sphinxtitleref{x\_k}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xB}} \textendash{} mean robot state \(x_{B_k}\)

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
updatd mean  state vector \(x_{k}\)

\end{description}\end{quote}

\end{fulllineitems}

\index{GetRobotStateCovariance() (FEKFMBL.FEKFMBL method)@\spxentry{GetRobotStateCovariance()}\spxextra{FEKFMBL.FEKFMBL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.GetRobotStateCovariance}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetRobotStateCovariance}}}{\sphinxparam{\DUrole{n}{Pk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Returns the robot covariance from the state covariance matrix.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Pk}} \textendash{} state vector covariance matrix \(P_k\)

\sphinxlineitem{Returns}
\sphinxAtStartPar
robot state covariance \(P_{B_k}\)

\end{description}\end{quote}

\end{fulllineitems}

\index{SetRobotStateCovariance() (FEKFMBL.FEKFMBL method)@\spxentry{SetRobotStateCovariance()}\spxextra{FEKFMBL.FEKFMBL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.SetRobotStateCovariance}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{SetRobotStateCovariance}}}{\sphinxparam{\DUrole{n}{Pk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{PB}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Updates the robot covariance from the state covariance matrix.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Pk}} \textendash{} state vector covariance matrix \(P_k\)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{PB}} \textendash{} robot state covariance \(P_{B_k}\)

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
updatd state covariance matrix \(P_{k}\)

\end{description}\end{quote}

\end{fulllineitems}

\index{SetRobotPose() (FEKFMBL.FEKFMBL method)@\spxentry{SetRobotPose()}\spxextra{FEKFMBL.FEKFMBL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.SetRobotPose}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{SetRobotPose}}}{\sphinxparam{\DUrole{n}{xk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{xB}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Updates the robot pose within the state vector.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xk}} \textendash{} mean of the state vector:math:\sphinxtitleref{x\_k}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xB}} \textendash{} mean robot pose \(x_{B_k}\)

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
updatd mean  state vector \(x_{k}\)

\end{description}\end{quote}

\end{fulllineitems}

\index{GetRobotPoseCovariance() (FEKFMBL.FEKFMBL method)@\spxentry{GetRobotPoseCovariance()}\spxextra{FEKFMBL.FEKFMBL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.GetRobotPoseCovariance}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetRobotPoseCovariance}}}{\sphinxparam{\DUrole{n}{Pk}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Returns the robot pose covariance from the state covariance matrix.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Pk}} \textendash{} state vector covariance matrix \(P_k\)

\sphinxlineitem{Returns}
\sphinxAtStartPar
robot pose covariance \(P_{B_k}\)

\end{description}\end{quote}

\end{fulllineitems}

\index{SetRobotPoseCovariance() (FEKFMBL.FEKFMBL method)@\spxentry{SetRobotPoseCovariance()}\spxextra{FEKFMBL.FEKFMBL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL.SetRobotPoseCovariance}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{SetRobotPoseCovariance}}}{\sphinxparam{\DUrole{n}{Pk}}\sphinxparamcomma \sphinxparam{\DUrole{n}{PB}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Updates the robot pose covariance from the state covariance matrix.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Pk}} \textendash{} state vector covariance matrix \(P_k\)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{PB}} \textendash{} robot pose covariance \(P_{B_k}\)

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
updated state covariance matrix \(P_{k}\)

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{4 DOF AUV}
\label{\detokenize{FEKFMBLocalization:dof-auv}}

\paragraph{4 DOF AUV Map based EKF Localization using an Input Velocity Motion Model with Depht, Yaw and Linear Velocity Measurements, and  a 2D Cartesian Feature Observation Model}
\label{\detokenize{FEKFMBLocalization:dof-auv-map-based-ekf-localization-using-an-input-velocity-motion-model-with-depht-yaw-and-linear-velocity-measurements-and-a-2d-cartesian-feature-observation-model}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{MBL_4DOFAUV_InputVelocityMM_2DCartesianFeatureOM}.png}
\end{figure}


\subsubsection{3 DOF Differential Drive Mobile Robot}
\label{\detokenize{FEKFMBLocalization:dof-differential-drive-mobile-robot}}

\paragraph{Differential Drive EKF Map Based Localization EKF Using an Input displacement Motion Model and 2D Cartesian Feature Observation Model}
\label{\detokenize{FEKFMBLocalization:differential-drive-ekf-map-based-localization-ekf-using-an-input-displacement-motion-model-and-2d-cartesian-feature-observation-model}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{MBL_3DOFDDInputDisplacementMM_2DCartesianFeatureOM}.png}
\end{figure}
\index{MBL\_3DOFDDInputDisplacementMM\_2DCartesianFeatureOM (class in MBL\_3DOFDDInputDisplacementMM\_2DCartesianFeatureOM)@\spxentry{MBL\_3DOFDDInputDisplacementMM\_2DCartesianFeatureOM}\spxextra{class in MBL\_3DOFDDInputDisplacementMM\_2DCartesianFeatureOM}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MBL_3DOFDDInputDisplacementMM_2DCartesianFeatureOM.MBL_3DOFDDInputDisplacementMM_2DCartesianFeatureOM}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{MBL\_3DOFDDInputDisplacementMM\_2DCartesianFeatureOM.}}\sphinxbfcode{\sphinxupquote{MBL\_3DOFDDInputDisplacementMM\_2DCartesianFeatureOM}}}{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.Cartesian2DMapFeature}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Cartesian2DMapFeature}}}}}, {\hyperref[\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{FEKFMBL}}}}}, {\hyperref[\detokenize{GFLocalization:EKF_3DOFDifferentialDriveInputDisplacement.EKF_3DOFDifferentialDriveInputDisplacement}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{EKF\_3DOFDifferentialDriveInputDisplacement}}}}}

\sphinxAtStartPar
Feature EKF Map based Localization of a 3 DOF Differential Drive Mobile Robot (\(x_k=[^Nx_{B_k} ~^Ny_{B_k} ~^N\psi_{B_k} ~]^T\)) using a 2D Cartesian feature map (\(M=[[^Nx_{F_1} ~^Ny_{F_1}] ~[x_{F_2} ~^Ny_{F_2}] ~... ~[^Nx_{F_n} ~^Ny_{F_n}]]^T\)),
and an input displacement motion model (:math:u\_k={[}\textasciicircum{}BDeltax\_k \textasciicircum{}BDelta y\_k \textasciicircum{}BDelta x psi\_k{]}\textasciicircum{}T\textasciigrave{}). The class inherits from the following classes:
* \sphinxcode{\sphinxupquote{Cartesian2DMapFeature}}: 2D Cartesian MapFeature using the Catesian coordinates for both, storage and landmark observations.
* \sphinxcode{\sphinxupquote{FEKFMBL}}: Feature EKF Map based Localization class.
* \sphinxcode{\sphinxupquote{EKF\_3DOFDifferentialDriveInputDisplacement}}: EKF for 3 DOF Differential Drive Mobile Robot with input displacement motion model.
\index{\_\_init\_\_() (MBL\_3DOFDDInputDisplacementMM\_2DCartesianFeatureOM.MBL\_3DOFDDInputDisplacementMM\_2DCartesianFeatureOM method)@\spxentry{\_\_init\_\_()}\spxextra{MBL\_3DOFDDInputDisplacementMM\_2DCartesianFeatureOM.MBL\_3DOFDDInputDisplacementMM\_2DCartesianFeatureOM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MBL_3DOFDDInputDisplacementMM_2DCartesianFeatureOM.MBL_3DOFDDInputDisplacementMM_2DCartesianFeatureOM.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Constructor of the FEKFMBL class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xBpose\_dim}} \textendash{} dimensionality of the robot pose within the state vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xB\_dim}} \textendash{} dimensionality of the state vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xF\_dim}} \textendash{} dimentsionality of a feature

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{zfi\_dim}} \textendash{} dimensionality of a single feature observation

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{M}} \textendash{} Feature Based Map \(M =[^Nx_{F_1}^T~...~^Nx_{F_{n_f}}^T]^T\)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{alpha}} \textendash{} Chi2 tail probability. Confidence interaval of the individual compatibility test

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{args}} \textendash{} arguments to be passed to the EKFLocalization constructor

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{Differential Drive EKF Map Based Localization EKF Using an Input displacement Motion Model and 2D Feature Store in Cartesina and Observed in Polar Coordinates}
\label{\detokenize{FEKFMBLocalization:differential-drive-ekf-map-based-localization-ekf-using-an-input-displacement-motion-model-and-2d-feature-store-in-cartesina-and-observed-in-polar-coordinates}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{MBL_3DOFDDInputDisplacementMM_2DCartesianFeatureOM}.png}
\end{figure}
\index{MBL\_3DOFDDInputDisplacementMM\_2DCartesianFeatureOM (class in MBL\_3DOFDDInputDisplacementMM\_2DCartesianFeatureOM)@\spxentry{MBL\_3DOFDDInputDisplacementMM\_2DCartesianFeatureOM}\spxextra{class in MBL\_3DOFDDInputDisplacementMM\_2DCartesianFeatureOM}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:id0}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{MBL\_3DOFDDInputDisplacementMM\_2DCartesianFeatureOM.}}\sphinxbfcode{\sphinxupquote{MBL\_3DOFDDInputDisplacementMM\_2DCartesianFeatureOM}}}{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{FEKFMBLocalization:MapFeature.Cartesian2DMapFeature}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Cartesian2DMapFeature}}}}}, {\hyperref[\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{FEKFMBL}}}}}, {\hyperref[\detokenize{GFLocalization:EKF_3DOFDifferentialDriveInputDisplacement.EKF_3DOFDifferentialDriveInputDisplacement}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{EKF\_3DOFDifferentialDriveInputDisplacement}}}}}

\sphinxAtStartPar
Feature EKF Map based Localization of a 3 DOF Differential Drive Mobile Robot (\(x_k=[^Nx_{B_k} ~^Ny_{B_k} ~^N\psi_{B_k} ~]^T\)) using a 2D Cartesian feature map (\(M=[[^Nx_{F_1} ~^Ny_{F_1}] ~[x_{F_2} ~^Ny_{F_2}] ~... ~[^Nx_{F_n} ~^Ny_{F_n}]]^T\)),
and an input displacement motion model (:math:u\_k={[}\textasciicircum{}BDeltax\_k \textasciicircum{}BDelta y\_k \textasciicircum{}BDelta x psi\_k{]}\textasciicircum{}T\textasciigrave{}). The class inherits from the following classes:
* \sphinxcode{\sphinxupquote{Cartesian2DMapFeature}}: 2D Cartesian MapFeature using the Catesian coordinates for both, storage and landmark observations.
* \sphinxcode{\sphinxupquote{FEKFMBL}}: Feature EKF Map based Localization class.
* \sphinxcode{\sphinxupquote{EKF\_3DOFDifferentialDriveInputDisplacement}}: EKF for 3 DOF Differential Drive Mobile Robot with input displacement motion model.
\index{\_\_init\_\_() (MBL\_3DOFDDInputDisplacementMM\_2DCartesianFeatureOM.MBL\_3DOFDDInputDisplacementMM\_2DCartesianFeatureOM method)@\spxentry{\_\_init\_\_()}\spxextra{MBL\_3DOFDDInputDisplacementMM\_2DCartesianFeatureOM.MBL\_3DOFDDInputDisplacementMM\_2DCartesianFeatureOM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:id2}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Constructor of the FEKFMBL class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xBpose\_dim}} \textendash{} dimensionality of the robot pose within the state vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xB\_dim}} \textendash{} dimensionality of the state vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xF\_dim}} \textendash{} dimentsionality of a feature

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{zfi\_dim}} \textendash{} dimensionality of a single feature observation

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{M}} \textendash{} Feature Based Map \(M =[^Nx_{F_1}^T~...~^Nx_{F_{n_f}}^T]^T\)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{alpha}} \textendash{} Chi2 tail probability. Confidence interaval of the individual compatibility test

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{args}} \textendash{} arguments to be passed to the EKFLocalization constructor

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{Differential Drive EKF Map Based Localization EKF Using an Input displacement Motion Model and 2D Polar Feature Observation Model}
\label{\detokenize{FEKFMBLocalization:differential-drive-ekf-map-based-localization-ekf-using-an-input-displacement-motion-model-and-2d-polar-feature-observation-model}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{MBL_3DOFDDInputDisplacementMM_2DPolarFeatureOM}.png}
\end{figure}
\index{MBL\_3DOFDDInputDisplacementMM\_2DPolarFeatureOM (class in MBL\_3DOFDDInputDisplacementMM\_2DPolarFeatureOM)@\spxentry{MBL\_3DOFDDInputDisplacementMM\_2DPolarFeatureOM}\spxextra{class in MBL\_3DOFDDInputDisplacementMM\_2DPolarFeatureOM}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MBL_3DOFDDInputDisplacementMM_2DPolarFeatureOM.MBL_3DOFDDInputDisplacementMM_2DPolarFeatureOM}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{MBL\_3DOFDDInputDisplacementMM\_2DPolarFeatureOM.}}\sphinxbfcode{\sphinxupquote{MBL\_3DOFDDInputDisplacementMM\_2DPolarFeatureOM}}}{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{PolarMapFeature}}, {\hyperref[\detokenize{FEKFMBLocalization:FEKFMBL.FEKFMBL}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{FEKFMBL}}}}}, {\hyperref[\detokenize{GFLocalization:EKF_3DOFDifferentialDriveInputDisplacement.EKF_3DOFDifferentialDriveInputDisplacement}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{EKF\_3DOFDifferentialDriveInputDisplacement}}}}}

\sphinxAtStartPar
Feature EKF Map based Localization of a 3 DOF Differential Drive Mobile Robot (\(x_k=[^Nx_{B_k} ~^Ny_{B_k} ~^N\psi_{B_k} ~]^T\)) using a 2D Cartesian feature map (\(M=[[^Nx_{F_1} ~^Ny_{F_1}] ~[x_{F_2} ~^Ny_{F_2}] ~... ~[^Nx_{F_n} ~^Ny_{F_n}]]^T\)),
and an input displacement motion model (:math:u\_k={[}\textasciicircum{}BDeltax\_k \textasciicircum{}BDelta y\_k \textasciicircum{}BDelta x psi\_k{]}\textasciicircum{}T\textasciigrave{}). The class inherits from the following classes:
* \sphinxcode{\sphinxupquote{Cartesian2DMapFeature}}: 2D Cartesian MapFeature using the Catesian coordinates for both, storage and landmark observations.
* \sphinxcode{\sphinxupquote{FEKFMBL}}: Feature EKF Map based Localization class.
* \sphinxcode{\sphinxupquote{EKF\_3DOFDifferentialDriveInputDisplacement}}: EKF for 3 DOF Differential Drive Mobile Robot with input displacement motion model.
\index{\_\_init\_\_() (MBL\_3DOFDDInputDisplacementMM\_2DPolarFeatureOM.MBL\_3DOFDDInputDisplacementMM\_2DPolarFeatureOM method)@\spxentry{\_\_init\_\_()}\spxextra{MBL\_3DOFDDInputDisplacementMM\_2DPolarFeatureOM.MBL\_3DOFDDInputDisplacementMM\_2DPolarFeatureOM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FEKFMBLocalization:MBL_3DOFDDInputDisplacementMM_2DPolarFeatureOM.MBL_3DOFDDInputDisplacementMM_2DPolarFeatureOM.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Constructor of the FEKFMBL class.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xBpose\_dim}} \textendash{} dimensionality of the robot pose within the state vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xB\_dim}} \textendash{} dimensionality of the state vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xF\_dim}} \textendash{} dimentsionality of a feature

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{zfi\_dim}} \textendash{} dimensionality of a single feature observation

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{M}} \textendash{} Feature Based Map \(M =[^Nx_{F_1}^T~...~^Nx_{F_{n_f}}^T]^T\)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{alpha}} \textendash{} Chi2 tail probability. Confidence interaval of the individual compatibility test

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{args}} \textendash{} arguments to be passed to the EKFLocalization constructor

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{Differential Drive EKF Map Based Localization EKF Using a Ct Velocity Motion Model and 2D Cartesian Feature Observation Model}
\label{\detokenize{FEKFMBLocalization:differential-drive-ekf-map-based-localization-ekf-using-a-ct-velocity-motion-model-and-2d-cartesian-feature-observation-model}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{MBL_3DOFDDInputDisplacementMM_2DCartesianFeaturePolarObservedOM}.png}
\end{figure}


\section{Simulatenous Localization And Mapping}
\label{\detokenize{Localization_index:simulatenous-localization-and-mapping}}

\subsection{Feature based EKF Simultaneous Localization And Mapping}
\label{\detokenize{Localization_index:feature-based-ekf-simultaneous-localization-and-mapping}}
\sphinxstepscope


\subsubsection{Feature based EKF Simultaneous Localization And Mapping}
\label{\detokenize{FEKFSLAM:feature-based-ekf-simultaneous-localization-and-mapping}}\label{\detokenize{FEKFSLAM::doc}}
\sphinxAtStartPar
To be completed


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}